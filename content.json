{"meta":{"title":"Richard Lee's Blog","subtitle":"You are what you program","description":"Personal Blog","author":"Richard Lee","url":"http://richardustc.github.io","root":"/"},"pages":[],"posts":[{"title":"about","slug":"about","date":"2020-08-11T10:41:54.000Z","updated":"2020-08-11T10:41:54.455Z","comments":true,"path":"2020-08-11-about.html","link":"","permalink":"http://richardustc.github.io/2020-08-11-about.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"python中的excepthook","slug":"except-hook","date":"2015-07-09T00:20:17.000Z","updated":"2020-08-11T09:20:58.662Z","comments":true,"path":"2015-07-09-except-hook.html","link":"","permalink":"http://richardustc.github.io/2015-07-09-except-hook.html","excerpt":"","text":"Python中，可以通过sys.excepthook来实现对Python程序中的exception的自定义处理 123456789101112131415import sysimport tracebackdef exception_printer(exc_type, exc_obj, traceback_obj): print(&quot;exception type: %s&quot; % type(exc_type)) print(&quot;exception object: %r&quot; % exc_obj) print(&quot;traceback content:\\n%s&quot; % &#39;\\n&#39;.join(traceback.format_tb(traceback_obj)))def test(): sys.excepthook &#x3D; exception_printer raise StandardError(&#39;test&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: test() 输出结果: 12345678exception type: &lt;type &#39;exceptions.StandardError&#39;&gt;exception object: StandardError(&#39;test&#39;,)traceback content: File &quot;C:\\Users\\richard\\Desktop\\test.py&quot;, line 14, in &lt;module&gt; test() File &quot;C:\\Users\\richard\\Desktop\\test.py&quot;, line 11, in test raise StandardError(&#39;test&#39;) 参考链接: https://docs.python.org/2/library/sys.html","categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/tags/Python/"}]},{"title":"使用Designer编写PyQt程序的简单流程","slug":"create-PyQt-Program-with-Designer","date":"2015-07-06T14:34:56.000Z","updated":"2020-08-11T09:20:58.702Z","comments":true,"path":"2015-07-06-create-PyQt-Program-with-Designer.html","link":"","permalink":"http://richardustc.github.io/2015-07-06-create-PyQt-Program-with-Designer.html","excerpt":"","text":"PyQt是一个非常方便的图形界面程序库，非常适合快速实现一个图形界面程序。Designer是Qt自带的一个界面设计工具，非常强大易用。 使用Designer的一般流程 打开Designer，编辑一个界面文件，保存为ui后缀的文件。假设我们创建了一个Main Window界面，这个ui文件名为MyWindow.ui。 使用pyuic4工具把ui文件转换成代码 1pyuic4 -i 0 MyWindow.ui -o MyWindow.py 在Windows上，可以写一个bat批处理来方便生成。使用下面这种方式可以在一个bat中添加多个转换。 1cmd &#x2F;c &quot;pyuic4 -i 0 MyWindow.ui -o MyWindow.py&quot; 查看生成的MyWindow.py文件，发现里面有一个类Ui_MainWindow。运行下面的代码就可以实现界面的展示了。 123456789101112131415from MyWindow import Ui_MainWindowclass MainWindow(QtGui.QMainWindow, Ui_MainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent) self.setupUi(self)if __name__ == &quot;__main__&quot;: app = QtGui.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) 接下来，按照需要扩展其他功能。","categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://richardustc.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://richardustc.github.io/tags/PyQt/"}]},{"title":"C# Type Basic","slug":"2013-12-14-c-sharp-basics","date":"2013-12-14T02:05:00.000Z","updated":"2020-08-11T09:20:58.742Z","comments":true,"path":"2013-12-14-2013-12-14-c-sharp-basics.html","link":"","permalink":"http://richardustc.github.io/2013-12-14-2013-12-14-c-sharp-basics.html","excerpt":"","text":"C#中所有的类型都有同一个基类object 类型种类 值类型：简单类型、枚举类型、结构体类型、可空类型 引用类型：类类型、接口类型、数组类型、委托类型值类型可以通过boxing转换成引用类型，也可以从引用类型unboxing转换成值类型。转换过程中发生数据拷贝。 内置类型sbyte/byte short/ushort int/uint long/ulong float double decimal bool char string注意：char类型跟C不一样，每一个char类型的变量可保存一个UTF-16字符，大小是2字节bool不能与整数类型相互转换decimal是用十进制存储的string类型是.NET Framework中String的别名，是一个引用类型，其他内置类型都是值类型。 123456789short i &#x3D; 0, j&#x3D;1;&#x2F;&#x2F;short k &#x3D; i+j; &#x2F;&#x2F;error, need conversionshort k &#x3D; (short)(i+j) &#x2F;&#x2F;right&#x2F;&#x2F; if(i) doSomething(); &#x2F;&#x2F;error, integer cannot be implicitly convert to boolean typeif(i !&#x3D; 0) doSomething(); &#x2F;&#x2F;rightfloat f &#x3D; 1.0F &#x2F;&#x2F; F&#x2F;f is essential. type of 1.0 is doubledecimal d &#x3D; 1.0M &#x2F;&#x2F; M&#x2F;m is essential. classC#中class结构与Java的形式类似。class类型的变量必须在堆上申请空间。class是单继承的，但是可以实现多个接口。class类型是引用类型 12345678910111213141516171819public class Person&#123; private int age; private string name; public Person(int age, string name) &#123; this.age &#x3D; age; this.name &#x3D; name; &#125;&#125;&#x2F;&#x2F;inheritancepublic class Student:Person&#123; private string studentNo; public Student(int age, string name, string studentNo) : base(age, name) &#123; self.studentNo &#x3D; studentNo; &#125;&#125; structstruct类型与类类型相似，但是不必在堆上申请空间，也不能被继承。struct类型不能有无参数构造函数，没有虚函数，没有finalizer。struct类型的构造函数必须初始化所有数据成员。struct类型是值类型。 123456789public struct Point&#123; int x,y; public Point(int x, int y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125;&#125; interfaceclass类型和struct类型都可以实现interface。interface所有成员都是public并且是abstract的。interface只能包含方法成员。interface也可以扩展interface。 123456789101112131415161718192021222324public interface Phone&#123; void Call(string number); void SendSMS(string content);&#125;public interface SmartPhone : Phone&#123; void InstallApp(string app);&#125;public class Android: SmartPhone&#123; void Call(string number) &#123; System.Console.WriteLine(&quot;calling &quot; + number); &#125; void SendSMS(string content) &#123; System.Console.WriteLine(&quot;sending message: &quot; + content); &#125; void InstallApp(string app) &#123; System.Console.WriteLine(&quot;installing app: &quot; + app); &#125;&#125; ###enumenum默认底层用int实现。 123456enum Direction&#123; East, West, North, South&#125;enum Direction2 : byte &#123; East, West, North, South &#125; &#x2F;&#x2F;use byte as underlaying type[Flags]enum Direction3&#123; East&#x3D;0, West&#x3D;1, North&#x3D;2, South&#x3D;4&#125;enum Direction3 d &#x3D; Direction3.East | Direction3.North;System.Console.WriteLine(d); &#x2F;&#x2F;will print &quot;East, North&quot; 可空类型可空类型是C#中比较特殊的类型。比如，int? a; int?是一种可空类型，a可以是一个int类型的值，也可以是null。 委托类型委托类型类似C语言中的函数指针，但是它是类型安全的，并且是面向对象的。 12345delegate double Function(double x); &#x2F;&#x2F;defined a new type &#39;Function&#39;static double Square(double x)&#123; return x*x;&#125;Function f &#x3D; Square;","categories":[{"name":"C#","slug":"C","permalink":"http://richardustc.github.io/categories/C/"}],"tags":[]},{"title":"构造随机数生成器","slug":"2013-09-26-generate-random-numbers","date":"2013-09-26T14:59:00.000Z","updated":"2020-08-11T06:56:28.606Z","comments":true,"path":"2013-09-26-2013-09-26-generate-random-numbers.html","link":"","permalink":"http://richardustc.github.io/2013-09-26-2013-09-26-generate-random-numbers.html","excerpt":"","text":"最近在准备找工作，碰到一些有意思的题目，其中一种就是利用现有的随机数生成器来构造新的随机数生成器。做了两道题之后，有一点体会，就此记录下来。假设原来的随机数生成器每个可能值出现的概率为p，新的随机数生成器每个可能值出现的概率为q。当p和q的大小关系不同时，有不同的做法。 p=q这种情况下，新的随机数生成器是最好构造的，只需要将新的生成器的可能值与原有的生成器的可能值一一对应即可。 例如，已有r1是随机生成1-5的随机数生成器，那么随机生成7-11的随机数生成器r2=r1+6。更一般的情况可以使用switch-case结构来实现一一对应。 123456789101112131415161718//simple exampleint r1();int r2()&#123; return r1()+6;&#125;//general exampleint r1();int r2()&#123; int result = r1(); switch(result)&#123; case r1_v1: return r2_v1; ... case r1_vn: return r2_vn; &#125;&#125; p&lt;q这种情况也比较好处理。只需要将一部分现有随机数生成器的可能值与新的随机数生成器的可能值做一一对应即可。 例如，已有r1是随机生成1-5的随机数生成器，那么随机生成0-1的随机数生成器r2的实现如下。更一般的情况可以使用switch-case结构来实现。 123456789101112131415161718192021222324252627//simple exampleint r1();int r2()&#123; int result; do&#123; result = r1(); &#125;while(result&lt;3); return result-1;&#125;//general exampleint r1();int r2()&#123; int result; do&#123; result = r1(); switch(result)&#123; case r1_v1: return r2_v1; ... case r1_vn: return r2_vn; default: //do nothing with other r2 possible values &#125; &#125;while(1);&#125; p&gt;q这种情况想对困难一些，也是经常被考察的一种情况。如果能够将情况转换成p&lt;q情况，那么就能很好的解决。看一个具体的实例。已有一个随机数生成器r1，随机生成0或1，现在需要构造一个新的随机生成器r2，使得r2能够随机生成1-5。 r2的可能值有6个，而r1只有两个。要用r1生成6个以上的值，可以通过加法的形式来完成。如果用两个r1相加，最多可以生成4个值，如果用3个r1相加，最多可以生成8个值，所以至少要3个r1相加。如果是r1+r1+r1，虽然生成了8个值，但是8个值中有相同的，导致每个值的概率是不一样的，不能用作随机数生成器。需要找到一个方法，让生成的8个值互不相同。考虑r3=r1+2r1+4r1，可能的生成值为0, 1, 2, 4, 3, 5, 6, 7。这8个值互不相同，每个出现的概率都是相同的。这个时候r3就是一个新的随机数生成器，并且符合p&lt;q的情况，可以用p&lt;q的解法来解决问题。 在更一般的情况下，构造r3 = a1*r1+a2*r1+…+am*r1。为了生成足够的可能值，需要满足n_r1^m &gt;= n_r2，其中n_r1和n_r2分别是r1和r2可能值的数目。在此基础上，还要让a1*r1+a2*r1+…+am*r1不出现重复值。 12345678910111213141516171819202122232425262728//simple exampleint r1();int r2()&#123; int result; do&#123; result = r1()+2*r1()+4*r2; &#125;while(result&lt;1 || result &gt; 5); return result;&#125;//general exampleint r1();int r2()&#123; int result; do&#123; result = a1*r1() + a2*r1() + ... + am*r1(); switch(result)&#123; case v1: return r2_v1; ... case vn: return r2_vn; default: //do nothing &#125; &#125;while(1);&#125;","categories":[],"tags":[]},{"title":"Python笔记","slug":"2013-09-16-python-notes","date":"2013-09-16T09:06:00.000Z","updated":"2020-08-11T06:56:28.605Z","comments":true,"path":"2013-09-16-2013-09-16-python-notes.html","link":"","permalink":"http://richardustc.github.io/2013-09-16-2013-09-16-python-notes.html","excerpt":"","text":"这篇文章里将会总结Python中的各种小知识点。 input和raw_input使用方法： 12s = raw_input(tip) # &#x27;tip&#x27; is a tipnumber = input(tip) raw_input读入之后以字符串的形式存储，而input则会讲读入的字符串做一次求值，得到的值得类型跟字符串内容相同。实际上，input是用raw_input来实现的。input(tip) – eval(raw_input(tip)) unpack使用方法： 1first, second, third, forth = sys.argv # There must be enough data for unpacking, otherwise exception will be raised Python常用标准库syssys.argvsys.exit([arg])sys.pathsys.stdinsys.stdoutsys.stderr osos.system(command)os.environ 一些数据结构 数据结构所在包 set默认 heapheapq dequecollections timetime.time()time.strftime(format)time.strptime(string[, format]) randomrandom.random()random.choice(seq)random.shuffle(seq[, random]) shelveshelve用于将内容存储到文件。 1234import shelves = shelve.open(&quot;output.dat&quot;)s[&#x27;key&#x27;] = values.close() rere.compile(pattern[, flags])re.search(pattern, string[, flags])re.match(pattern, string[, flags])re.split(pattern, string[, maxsplit=0])re.findall(pattern, string)re.sub(pattern, replace, string[, count=0])matchObj.group([groupNum1, …])matchObj.start([groupNum])matchObj.end([groupNum])matchObj.span([groupNum])","categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"}],"tags":[]},{"title":"LD_PRELOAD的作用","slug":"2013-08-22-ld-preload","date":"2013-08-22T07:00:00.000Z","updated":"2020-08-11T06:56:28.605Z","comments":true,"path":"2013-08-22-2013-08-22-ld-preload.html","link":"","permalink":"http://richardustc.github.io/2013-08-22-2013-08-22-ld-preload.html","excerpt":"","text":"LD_PRELOAD用于指定提前加载一些动态库，这些动态库比libc.so等库装载更早，它们提供的函数能够屏蔽后加载的动态库中的函数。这个特性可以方便地用来截获库函数调用。 例如，有一个已经编译好的程序使用malloc分配内存，你想使用Google开发的tcmalloc来提升效率，使用LD_PRELOAD可以实现这个目的。 下面举一个小例子来说用LD_PRELOAD的使用。 源文件malloc.c123456#include &lt;stdio.h&gt;typedef unsigned long size_t;void *malloc(size_t size)&#123; printf(&quot;malloc(%ld)\\n&quot;, size); return NULL;&#125; test.c12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf(&quot;start.\\n&quot;); malloc(10); printf(&quot;end.\\n&quot;); return 0;&#125; 运行首先，使用普通方法运行。 12gcc test.c -o test./test 程序输出： 12start.end. 接下来，讲malloc.c编译成动态链接库 12gcc -fPIC -shared malloc.c -o malloc.soLD_PRELOAD=./malloc.so ./test 程序输出： 123start.malloc(10)end. 可以看出，使用LD_PRELOAD之后，我们自定义的malloc取代了库函数中的malloc。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[]},{"title":"Undefined reference to typeinfo","slug":"2013-07-22-undefined-reference-to-typeinfo","date":"2013-07-22T06:34:00.000Z","updated":"2020-08-11T06:56:28.604Z","comments":true,"path":"2013-07-22-2013-07-22-undefined-reference-to-typeinfo.html","link":"","permalink":"http://richardustc.github.io/2013-07-22-2013-07-22-undefined-reference-to-typeinfo.html","excerpt":"","text":"在项目中遇到了这样一个问题：C++文件编译都OK，但链接的时候报错：undefined reference to `typeinfo for xxx’。typeinfo是C++中的RTTI(RunTime Type Identification)机制中记录类型信息用的，dynamic_cast和typeid操作符会使用这些信息。 以”undefined reference to typeinfo”为关键字在网络上搜索，大多数都是说有虚函数定义了但是未实现导致的。但是我的代码显然不是这个情况。在我即将放弃的时候，终于在StackOverflow上发现有人提出，这种错误的原因也可能是混合使用了带RTTI信息和不带RTTI信息的代码导致的。对比检查，发现我的项目里的问题正是这个。最后用了一点dirty hack，解决了bug。下面就仔细分析一下”undefined reference to `typeinfo for xxx’”产生的原因。 虚函数未实现产生”undefined reference to `typeinfo for xxx’”最常见的原因就是基类的虚函数未实现了。由于C++类的实现可以分布在多个源文件中，所以生成目标文件时，基类的虚函数没有定义是不会报错的。但是链接成可执行文件时，需要将虚函数的信息放进typeinfo中，这个时候虚函数未实现就会引发这个错误。 混用了no-RTTI代码和RTTI代码我碰到的正是混用了no-RTTI和RTTI代码的情形。项目中我们自己写的程序必须开启RTTI，而我们使用的外部的一个库使用no-RTTI编译。我们在自己的代码中需要重载一个外部库中的带虚函数的类，结果链接的时候就出现了问题。外部库中的基类使用-fno-rtti选项编译，生成的代码没有typeinfo信息，而我们的代码使用-frtti选项编译，要求基类必须要有typeinfo信息。最后，我在编译系统中做了一些dirty hack，让那个派生类所在的源文件以-fno-rtti选项编译，解决了问题。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[]},{"title":"在LLVM IR中绑定外部的变量和函数","slug":"2013-07-07-llvm-bind-global-variable","date":"2013-07-07T08:58:00.000Z","updated":"2020-08-11T06:56:28.604Z","comments":true,"path":"2013-07-07-2013-07-07-llvm-bind-global-variable.html","link":"","permalink":"http://richardustc.github.io/2013-07-07-2013-07-07-llvm-bind-global-variable.html","excerpt":"","text":"前面的文章中提到了如何利用LLVM的IR进行编程，这篇文章将讲述如何将LLVM IR外部的变量和函数与LLVM IR结合起来。 LLVM IR外部变量和外部函数外部变量value和外部函数foo： 12345int value = 10;int foo(int x)&#123; return 2*x;&#125; 声明LLVM IR中的外部变量和函数声明一个外部变量value，为int类型。 12LLVMContext &amp; context = llvm::getGlobalContext();GlobalVariable *v = cast&lt;GlobalVariable&gt;(module-&gt;getOrInsertGlobal(&quot;value&quot;, Type::getInt32Ty(context))); 声明一个外部函数foo，这个函数的原型为int foo(int x) 12Function *f = cast&lt;Function&gt;(module-&gt;getOrInsertFunction(&quot;foo&quot;, Type::getInt32Ty(context), Type::getInt32Ty(context), NULL)); 构建一个LLVM IR表示的函数接下来构建一个LLVM IR表示的函数bar。在bar中读入value的值，并作为foo的参数调用foo，bar再返回foo的返回值。 12345678910111213//create a LLVM function &#x27;bar&#x27;Function* bar = cast&lt;Function&gt;(module-&gt;getOrInsertFunction(&quot;bar&quot;, Type::getInt32Ty(context),NULL));//basic block constructionBasicBlock* entry = BasicBlock::Create(context, &quot;entry&quot;, bar);IRBuilder&lt;&gt; builder(entry);//read &#x27;value&#x27;Value * v_IR = builder.CreateLoad(v);//call foo(value)Value * ret = builder.CreateCall(f, v_IR);//return return value of &#x27;foo&#x27;builder.CreateRet(ret); 创建ExecutionEngine123//create execution engine firstInitializeNativeTarget();ExecutionEngine *ee = EngineBuilder(module).setEngineKind(EngineKind::JIT).create(); 绑定LLVM IR外部的变量和函数12345//map global variableee-&gt;addGlobalMapping(v, &amp;value);//map global functionee-&gt;addGlobalMapping(f, (void *)foo); JIT并运行12345void *barAddr = ee-&gt;getPointerToFunction(bar);typedef int (*FuncType)();FuncType barFunc = (FuncType)barAddr;std::cout &lt;&lt; barFunc() &lt;&lt; std::endl; 运行结果是20，正好符合语义。 重新绑定LLVM IR外部变量或者外部函数重新绑定LLVM IR外部变量或函数可以通过updateGlobalMapping来实现。 12ee-&gt;updateGlobalMapping(v, &amp;value1);ee-&gt;updateGlobalMapping(f, (void *)foo1); 不过重新绑定之后，需要重新JIT才可以将改变反应到生成代码上来。 本文示例地址：llvm-ir-global-mapping","categories":[{"name":"LLVM","slug":"LLVM","permalink":"http://richardustc.github.io/categories/LLVM/"}],"tags":[]},{"title":"使用llc C++后端辅助LLVM IR编程","slug":"2013-07-07-llc-cpp-backend","date":"2013-07-07T07:23:00.000Z","updated":"2020-08-11T06:56:28.603Z","comments":true,"path":"2013-07-07-2013-07-07-llc-cpp-backend.html","link":"","permalink":"http://richardustc.github.io/2013-07-07-2013-07-07-llc-cpp-backend.html","excerpt":"","text":"llc是LLVM提供的一个工具，以LLVM bitcode或LLVM汇编为输入，根据指定的后端生成相应的代码。通常情况下，后端跟某一种ISA相关，比如x86、mips、arm等，指定这些后端就会生成在相应处理器上运行的机器码。但是llc还支持一种特殊的后端：cpp。指定这种后端的时候，输出的是C++代码，而这些C++代码正好就是利用LLVM的IR API编程。所以可以利用这种方法来学习如何进行LLVM的IR编程。 ##检查llc是否支持cpp后端有时候发行版自带的llc可能并不支持cpp后端，比如ubuntu 13.04。查看llc支持的后端可以用以下命令 1llc --version 如果输出中包含”cpp - C++ backend”，那么说明支持C++后端了。 ##编写源文件这里给一个最简单的示例test.c 1int main()&#123;return 0;&#125; ##生成bitcode生成LLVM的bitcode可以用clang，也可以用llvmgcc。 clang： 1clang -emit-llvm -c test.c llvmgcc： 1llvmgcc -emit-llvm -c test.c 生成的LLVM bitcode代码文件后缀为.o ##生成LLVM汇编（可选）可以从源文件生成LLVM汇编，也可以从bitcode生成汇编。 使用clang从源文件生成LLVM汇编： 1clang -emit-llvm -S test.c 使用llvmgcc从源文件生成LLVM汇编： 1llvmgcc -emit-llvm -S test.c 使用llvm-dis从bitcode生成LLVM汇编 1llvm-dis test.o 生成的LLVM汇编内容： 12345678910111213; ModuleID &#x3D; &#39;test.o&#39;target datalayout &#x3D; &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot;; Function Attrs: nounwind uwtabledefine i32 @main() #0 &#123;entry: %retval &#x3D; alloca i32, align 4 store i32 0, i32* %retval ret i32 0&#125;attributes #0 &#x3D; &#123; nounwind uwtable &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot;&#x3D;&quot;true&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125; ##生成C++代码使用llc生成C++代码，输入可以是bitcode，也可以是LLVM汇编。使用bitcode作为输入： 1llc -march=cpp test.o 使用LLVM汇编作为输入，假设汇编文件为test.s： 1llc -march=cpp test.s 会生成一个test.o.cpp或test.s.cpp文件，从这个文件可以看到如何利用LLVM的IR进行编程。 生成的代码有一百多行，在此就不贴出来了。","categories":[{"name":"LLVM","slug":"LLVM","permalink":"http://richardustc.github.io/categories/LLVM/"}],"tags":[]},{"title":"如何使用Calibre Recipe","slug":"2013-06-22-calibre-recipe-howto","date":"2013-06-22T13:57:00.000Z","updated":"2020-08-11T06:56:28.603Z","comments":true,"path":"2013-06-22-2013-06-22-calibre-recipe-howto.html","link":"","permalink":"http://richardustc.github.io/2013-06-22-2013-06-22-calibre-recipe-howto.html","excerpt":"","text":"Calibre Recipe是Calibre用来抓取网页或RSS并制作成电子书的脚本。Calibre Recipe的使用方法有两种： 图形界面下使用添加Recipe 首先打开Calibre 点击“抓取新闻”右边的的“v”，选择添加“自定义新闻源” 点击“切换到高级模式” 将下载的Recipe文件的内容复制到高级模式下的文本框里，完全覆盖原来的内容 点击“添加/更新订阅清单” 关闭，选“是”即可 下载转换 在Calibre主界面点击“抓取新闻” 选择“自定义” 选择要下载的条目，点击右下角的“立即下载” 或者勾选“计划下载”，设置按计划下载。 命令行下使用在安装了Calibre的机器上，可以使用如下命令来使用Recipe下载并转换电子书： 假设Recipe的名称为myrecipe.recipe。 生成mobi 1ebook-convert myrecipe.recipe .mobi 生成epub 1ebook-convert myrecipe.recipe .epub 欢迎下载使用[我写的recipe][recipe][recipe]: https://github.com/RichardUSTC/calibre-recipes","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[]},{"title":"javascript basic concept","slug":"2013-06-20-javascript-basic-concept","date":"2013-06-20T13:11:00.000Z","updated":"2020-08-11T06:56:28.602Z","comments":true,"path":"2013-06-20-2013-06-20-javascript-basic-concept.html","link":"","permalink":"http://richardustc.github.io/2013-06-20-2013-06-20-javascript-basic-concept.html","excerpt":"","text":"以前也学过一段时间的Javascript，但是长时间不用，很多东西已经忘记了。趁此机会总结一下Javascript的基本用法。 Javascript的位置head内1234567&lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function hello()&#123; alert(&quot;hello, world.&quot;); &#125; &lt;/script&gt; &lt;/head&gt; body内1234567&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function hello()&#123; alert(&quot;hello, world.&quot;); &#125; &lt;/script&gt; &lt;/body&gt; 外部Javascript文件 Javascript的语句Javascript的语句可以以’;’结尾，也可以以换行来结尾。如果需要断行，可以使用’&#39;。 1234alert(&quot;1&quot;);alert(&quot;2&quot;)alert(&quot;\\3&quot;) Javascript注释123456// comment in one line/* comment in multiple line*/ Javascript变量 Javascript中所有的变量都是对象。 Javascript变量类型是动态可变的。 第一次初始化之前不声明，则变量是全局的。如果有声明，那么变量的作用域为变量声明所在的域。 Javascript变量未初始化之前为undefined。123var x;x = 1;x = &quot;hello&quot; Javascript中的数据类型字符串1234var s1 = &quot;hello&quot;;var s2 = &quot;world&quot;;var s3 = x + y;var s4 = &quot;hello, &#x27;world&#x27;&quot;; 数字1234var num1 = 1;var num2 = 1.1;var num3 = 1e10;var num4 = 1e-3; 布尔值12var b1 = true;var b2 = false; 数组123456var arr = new Array();arr[0] = 1;arr[1] = &quot;2&quot;;var arr2 = new Array(1, &quot;2&quot;);var arr3 = [1, &quot;2&quot;];arr.length 对象1234567891011121314var obj1 = &#123;f1:1, f2:&quot;2&quot;&#125;;var i = obj1.f1;var s = obj1.f2;var obj2 = new Object();obj2.f1 = 1;obj2.f2 = &quot;2&quot;;function person(name, age)&#123; this.name = name; this.age = age;&#125;sam = new person(&quot;Sam&quot;, &quot;10&quot;); Javascript函数123456function func1(arg1, arg2)&#123; return arg1 + arg2;&#125;func2 = function(arg1, arg2)&#123; return arg1 + arg2;&#125; Javascript运算符 +, -, *, /, % ++, – =, +=, -=, *=, /=, %= ==, ===, !=, &gt;, &lt;, &gt;=, &lt;= &amp;&amp;, ||, ! Javascript语句条件语句与C语言类似 switch语句与C语言类似 循环语句for循环123456for(var i=0; i&lt;length; i++)&#123; arr[i] = i;&#125;for(var i in x)&#123; arr[i] = 0;&#125; while循环与C语言类似 do..while循环与C语言类似 break语句不带标签时与C语言类似 123456789101112131415161718192021222324list:&#123; document.write(cars[0] + &quot;&lt;br&gt;&quot;); document.write(cars[1] + &quot;&lt;br&gt;&quot;); document.write(cars[2] + &quot;&lt;br&gt;&quot;); break list; // The next three statement will not be executed document.write(cars[3] + &quot;&lt;br&gt;&quot;); document.write(cars[4] + &quot;&lt;br&gt;&quot;); document.write(cars[5] + &quot;&lt;br&gt;&quot;); &#125;var iNum = 0;outermost:for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; iNum++; &#125;&#125;alert(iNum); //输出 &quot;55&quot; continue语句不带标签时与C语言类似 123456789101112var iNum = 0;outermost:for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; iNum++; &#125;&#125;alert(iNum); //输出 &quot;95&quot; try..catch1234567try&#123; //do something //throw some_err //do something&#125;catch(err)&#123; //deal with error&#125; Javascript操作DOM查找12var x=document.getElementById(&quot;intro&quot;);var y=x.getElementsByTagName(&quot;p&quot;); 改变HTML1234document.write(&quot;new content&quot;) // originally contents will be flusheddocument.getElementById(&quot;header&quot;).innerHTML=&quot;new header&quot;;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;; 针对事件做出反应1document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;; DOM事件列表 创建新的HTML元素123var para=document.createElement(&quot;p&quot;);var node=document.createTextNode(&quot;这是新段落。&quot;);para.appendChild(node); 删除HTML元素123var parent=document.getElementById(&quot;div1&quot;);var child=document.getElementById(&quot;p1&quot;);parent.removeChild(child); Javascript Cheat SheetJavascript Cheat Sheet","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://richardustc.github.io/categories/Javascript/"}],"tags":[]},{"title":"一个可执行文件的72变","slug":"2013-06-20-72-transformation-of-one-executable","date":"2013-06-20T09:21:00.000Z","updated":"2020-08-11T06:56:28.602Z","comments":true,"path":"2013-06-20-2013-06-20-72-transformation-of-one-executable.html","link":"","permalink":"http://richardustc.github.io/2013-06-20-2013-06-20-72-transformation-of-one-executable.html","excerpt":"","text":"同一个可执行文件，改成不同的名字，就拥有不同的功能？ 我最早看到的这种拥有“72变”能力的可执行文件就是大名鼎鼎的busybox。经过一番思考，我弄明白了其中的原理，现在在这里剖析一下。先来看一看一个简单的test.c test.c12345#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; printf(&quot;%s\\n&quot;, argv[0]); return 0;&#125; 编译运行 123456$ gcc test.c -o test$ .&#x2F;test.&#x2F;test$ cp test test1$ .&#x2F;test1.&#x2F;test1 之所以会产生这样的结果是因为传给main的参数argv中的argv[0]始终存储着可执行文件的路径。利用这个特性，我们就可以写出一个拥有“72变”能力的程序了。 下面给出一个拥有“3变”能力的例子。 3.c1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;libgen.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; //get the name of the executable char *path = strdup(argv[0]); char *bname = basename(path); if(!strcmp(bname, &quot;happy&quot;))&#123; printf(&quot;I&#x27;m happy!\\n&quot;); &#125; else if(!strcmp(bname, &quot;unhappy&quot;))&#123; printf(&quot;I&#x27;m not happy!\\n&quot;); &#125; else&#123; printf(&quot;To be, or not to be, that is the question.\\n&quot;); &#125; return 0;&#125; 编译运行： 123456789$ gcc 3.c -o happy$ .&#x2F;happyI&#39;m happy!$ mv happy unhappy$ .&#x2F;unhappyI&#39;m not happy!$ mv unhappy x$ .&#x2F;xTo be, or not to be, that is the question. Shell脚本也可以玩这一招 3.sh123456789101112#!/bin/shbname=`basename $0`if [ $bname = &quot;happy&quot; ]then echo &quot;I&#x27;m happy!&quot;elif [ $bname = &quot;unhappy&quot; ]then echo &quot;I&#x27;m not happy!&quot;else echo &quot;To be, or not to be, that is the question.&quot;fi","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[]},{"title":"使用LLVM IR编程","slug":"2013-06-19-programming-with-llvm-ir","date":"2013-06-19T08:40:00.000Z","updated":"2020-08-11T06:56:28.602Z","comments":true,"path":"2013-06-19-2013-06-19-programming-with-llvm-ir.html","link":"","permalink":"http://richardustc.github.io/2013-06-19-2013-06-19-programming-with-llvm-ir.html","excerpt":"","text":"最近做的工作要使用LLVM IR来进行编程，借这篇文章来整理一下最近学到的一些东西。LLVM是一个非常有名的编译器基础设施。访问LLVM官方网站获得更多信息。 LLVM IR简介LLVM有自己的一套中间表示IR(Intermedia Representation)。IR在编译器中承担着一个承前启后的角色。编译器前端对源程序进行语法和语义分析，生成IR。编译器后端则将IR汇编成对应的机器指令。此外，编译器中大部分的优化都是在IR上完成的。 LLVM的IR功能强大，其形式类似于RISC机器的指令。LLVM可以使用解释来执行IR，也可以利用JIT将IR翻译成对应的机器指令。 LLVM IR相关概念使用LLVM IR编程要涉及到Module, Function, BasicBlock, Instruction, ExecutionEngine等概念。下面对这些概念进行一个简单的说明。 Module可以将LLVM中的Module类比为C程序中的源文件。一个C源文件中包含函数和全局变量定义、外部函数和外部函数声明，一个Module中包含的内容也基本上如此，只不过C源文件中是源码来表示，Module中是用IR来表示。 FunctionFunction是LLVM JIT操作的基本单位。Function被Module所包含。LLVM的Function包含函数名、函数的返回值和参数类型。Function内部则包含BasicBlock。 BasicBlockBasicBlock与编译技术中常见的基本块(basic block)的概念是一致的。BasicBlock必须以跳转指令结尾。 InstructionInstruction就是LLVM IR的最基本单位。Instruction被包含在BasicBlock中。 ExecutionEngineExecutionEngine是用来运行IR的。运行IR有两种方式：解释运行和JIT生成机器码运行。相应的ExecutionEngine就有两种：Interpreter和JIT。ExecutionEngine的类型可以在创建ExecutionEngine时指定。 LLVM IR编程基本流程 创建一个Module 在Module中添加Function 在Function中添加BasicBlock 在BasicBlock中添加指令 创建一个ExecutionEngine 使用ExecutionEngine来运行IR LLVM IR编程示例与说明注意： LLVM处于快速发展之中，其API变化非常大，不同版本之间的API可能不兼容。本文的示例都基于LLVM 2.9。 创建ModuleModule创建时需要一个context，通常使用global context。在例子中，Module的name被设置为test。 123// Module ConstructionLLVMContext &amp; context = llvm::getGlobalContext();Module* module = new Module(&quot;test&quot;, context); 在Module中添加Function在Module中添加Function的方法比较多，这里介绍一种比较简洁的方法。下面的代码生成了一个函数void foo(void)。 123456Constant* c = module-&gt;getOrInsertFunction(&quot;foo&quot;,/*ret type*/ Type::getVoidTy(context),/*args*/ Type::getVoidTy(context),/*varargs terminated with null*/ NULL);Function* foo = cast&lt;Function&gt;(c); /* cast is provided by LLVMfoo-&gt;setCallingConv(CallingConv::C); 到目前为止，还没有添加BasicBlock，函数foo仅仅是一个函数原型。第6行设置foo遵循C函数调用的规则。LLVM中的函数支持多种调用规则，通常使用C的调用规则即可。更多调用规则可以参考llvm::CallingConv::ID。 在Function中添加BasicBlock创建BasicBlock可以使用BasicBlock类的静态函数Create。 1BasicBlock* block = BasicBlock::Create(context, &quot;entry&quot;, foo); 第三个参数foo表示将block插入到Function foo中。 在BasicBlock中添加指令下面介绍一个在BasicBlock中添加指令的简洁方法。这个方法使用了一个工厂类IRBuilder的实例builder。首先，初始化builder。 1IRBuilder&lt;&gt; builder(block); 这里将block作为参数表示接下来的指令将被插入到block中。 接下来的一段代码开始向block中插入代码。含义包含在注释中。 12345678910111213141516171819202122232425262728293031//Create three constant integer x, y, z.Value *x = ConstantInt::get(Type::getInt32Ty(context), 3);Value *y = ConstantInt::get(Type::getInt32Ty(context), 2);Value *z = ConstantInt::get(Type::getInt32Ty(context), 1);//addr = &amp;value/* we will check the value of &#x27;value&#x27; and see** whether the function we construct is running correctly.*/long value = 10;Value * addr = builder.CreateIntToPtr( ConstantInt::get(Type::getInt64Ty(context), (uint64_t)&amp;value), Type::getInt64PtrTy(context), &quot;addr&quot;);// mem = [addr]Value* mem = builder.CreateLoad(addr, &quot;mem&quot;);// tmp = 3*memValue* tmp = builder.CreateBinOp(Instruction::Mul, x, mem, &quot;tmp&quot;);// tmp2 = tmp+2Value* tmp2 = builder.CreateBinOp(Instruction::Add, tmp, y, &quot;tmp2&quot;);// tmp3 = tmp2-1Value* tmp3 = builder.CreateBinOp(Instruction::Sub, tmp2, z, &quot;tmp3&quot;);// [addr] = membuilder.CreateStore(tmp3, addr); // retbuilder.CreateRetVoid(); 至此，我们通过LLVM的IR生成一个Module test，这个Module中包含一个Function foo，而foo中包含一个BasicBlock entry。 展示已经生成的IR我们可以使用Module的dump方法先展示目前的成果。 1module-&gt;dump(); 输出结果 12345678910111213; ModuleID &#x3D; &#39;test&#39;define void @foo(void) &#123;entry: ; the number &#39;140735314124408&#39; maybe different on your machine. %mem &#x3D; load i64* inttoptr (i64 140735314124408 to i64*) %tmp &#x3D; mul i32 3, i64 %mem %tmp2 &#x3D; add i32 %tmp, 2 %tmp3 &#x3D; sub i32 %tmp2, 1 ; the number &#39;140735314124408&#39; maybe different on your machine. store i32 %tmp3, i64* inttoptr (i64 140735314124408 to i64*) ret void&#125; 创建ExecutionEngine接下来就要使用ExecutionEngine来生成代码了。 创建一个JIT类型的ExecutionEngine，为了便于观察IR生成的机器码，设置为不优化。 123InitializeNativeTarget(); ExecutionEngine *ee = EngineBuilder(module).setEngineKind(EngineKind::JIT) .setOptLevel(CodeGenOpt::None).create(); 生成机器指令JIT生成机器指令以Function为单位。 12void * fooAddr = ee-&gt;getPointerToFunction(foo);std::cout &lt;&lt;&quot;address of function &#x27;foo&#x27;: &quot; &lt;&lt; std::hex &lt;&lt; fooAddr &lt;&lt; std::endl; 如果用gdb跟踪函数执行，待输出fooAddr后，用x/i命令，即可查看foo对应的机器指令。例如，我的X86_64机器上输出为： 123456780x7ffff7f6d010: movabs $0x7fffffffe2b0,%rax0x7ffff7f6d01a: mov $0x3,%ecx0x7ffff7f6d01f: mov (%rax),%edx0x7ffff7f6d021: imul %ecx,%edx0x7ffff7f6d024: add $0x2,%edx0x7ffff7f6d02a: sub $0x1,%edx0x7ffff7f6d030: mov %edx,(%rax)0x7ffff7f6d032: retq 运行机器指令使用类型转换将fooAddr转换成一个函数fooFunc，然后调用。 123456//Run the functionstd::cout &lt;&lt; std::dec &lt;&lt; &quot;Before calling foo: value = &quot; &lt;&lt; value &lt;&lt; std::endl;typedef void (*FuncType)(void);FuncType fooFunc = (FuncType)fooAddr;fooFunc();std::cout &lt;&lt; &quot;After calling foo: value = &quot; &lt;&lt; value &lt;&lt; std::endl; 我们使用value的值来检验foo构造的正确性。运行之后的输出 12Before calling foo: value &#x3D; 10After calling foo: value &#x3D; 31 经过验算，foo的功能是正确的。 直接生成并运行机器指令ExecutionEngine还提供一个接口runFunction直接JIT并运行机器指令。具体做法可以参考LLVM::ExecutionEngine::runFunction的文档。 代码本文中的全部代码可以在这里查看。","categories":[{"name":"LLVM","slug":"LLVM","permalink":"http://richardustc.github.io/categories/LLVM/"}],"tags":[]},{"title":"正则表达式与diff的结合","slug":"2013-06-09-diff-with-regex","date":"2013-06-09T06:12:00.000Z","updated":"2020-08-11T06:56:28.601Z","comments":true,"path":"2013-06-09-2013-06-09-diff-with-regex.html","link":"","permalink":"http://richardustc.github.io/2013-06-09-2013-06-09-diff-with-regex.html","excerpt":"","text":"diff是Linux下一个非常有用的工具，主要用来比较两个文件的不同。有时候，需要diff的两个文件中包含一些无关的信息，这些信息不同，导致diff的结果很复杂，难于分析。碰到这种情况，通常是利用sed之类的工具去掉源文件中的无关信息，生成临时文件，再对临时文件做diff。diff完成之后再删除临时文件。 今天刚好搜到StackOverflow上的一个问答，直接用diff的功能解决了这个问题，无需再创建和删除临时文件了。 12diff --label example_file1 &lt;(sed &#x27;s/example_old1_regex/example_new1_regex/&#x27; example_file1) \\ --label example_file2 &lt;(sed &#x27;s/example_old2_regex/example_new2_regex/&#x27; example_file2)","categories":[{"name":"Command-Line","slug":"Command-Line","permalink":"http://richardustc.github.io/categories/Command-Line/"}],"tags":[]},{"title":"正则表达式中的断言","slug":"2013-06-04-assertion-in-regular-expression","date":"2013-06-04T13:45:00.000Z","updated":"2020-08-11T06:56:28.601Z","comments":true,"path":"2013-06-04-2013-06-04-assertion-in-regular-expression.html","link":"","permalink":"http://richardustc.github.io/2013-06-04-2013-06-04-assertion-in-regular-expression.html","excerpt":"","text":"正则表达式主要用于文本匹配，并从匹配的文本中提取出感兴趣的字段。正则表达式的应用非常广泛，已经有非常多的编程语言和工具支持正则表达式。这里有一篇文章30分钟学会正则表达式。本文主要记录一下正则表达式中的零宽断言，因为这一部分是我平时很少用到，掌握不牢的部分。 零宽断言是正则表达式中匹配位置的一种方式。零宽断言分为以下几种： 零宽度正预测先行断言 语法：(?=&lt;exp&gt;) 含义：从当前位置开始向前（向右）成功匹配exp，则匹配位置成功 示例：(?=abc) 示例含义：匹配向右看三个字符是’abc’的位置 零宽度负预测先行断言 语法：(?!&lt;exp&gt;) 含义：从当前位置开始向前（向右）无法成功匹配exp，则匹配位置成功 示例：(?!abc) 示例含义：匹配向右看三个字符不是’abc’的位置 零宽度正回顾后发断言 语法：(?&lt;=&lt;exp&gt;) 含义：从当前位置开始向后（向左）成功匹配exp，则匹配位置成功 示例：(?&lt;=abc) 示例含义：匹配往左看连续三个字符为’abc’的位置 零宽度负回顾后发断言 语法：(?&lt;!&lt;exp&gt;) 含义：从当前位置开始向后（向左）无法成功匹配exp，则匹配位置成功 示例：(?&lt;!abc) 示例含义：匹配往左看连续三个字符不为’abc’的位置","categories":[{"name":"Regex","slug":"Regex","permalink":"http://richardustc.github.io/categories/Regex/"}],"tags":[]},{"title":"利用wget复制网站","slug":"2013-05-27-wget","date":"2013-05-27T05:51:00.000Z","updated":"2020-08-11T06:56:28.600Z","comments":true,"path":"2013-05-27-2013-05-27-wget.html","link":"","permalink":"http://richardustc.github.io/2013-05-27-2013-05-27-wget.html","excerpt":"","text":"曾经维护过一个网站，但是为了成本和安全性多方面的考虑，主机上只host静态网页。于是就在自己的机器上搭建wordpress环境，在本地更新内容之后，使用wget将整个网站复制下来，再上传到远程主机上。整个网页看起来和直接使用wordpress是一模一样的。 使用的命令如下： 1wget -E -c -r -p -k -np -l 100 http://localhost/example/ 下面分别解释一下各个参数的含义： -E: 如果下载了一个网页文件，但是没有后缀，使用这个选项会自动调整后缀为html。这个选项在处理动态网站的时候很有用。比如http://localhost/example/?key=123。等同--adjust-extension。 -c: 续传，等同--continue。 -r: 递归下载，等同--recursive。使用这个选项之后，wget会自动找到当前页面中的链接，并下载链接对应的文件。 -p: 下载正常显示页面所需要的所有资源文件，比如内置图片、css文件等等，等同与--page-requisites。 -k: 将链接中的绝对路径转换为相对路径，这样下载的文件可以放置在任何位置访问，等同于--convert-links。 -np: 不下载指定url的父目录中的文件，在本例中，这个选项表示只下载目标网站example/目录下的文件，等同于--no-parent。","categories":[{"name":"Command-Line","slug":"Command-Line","permalink":"http://richardustc.github.io/categories/Command-Line/"}],"tags":[]},{"title":"mmap x86小于0x10000的虚地址","slug":"2013-05-21-min-mmap-addr","date":"2013-05-21T14:03:00.000Z","updated":"2020-08-11T06:56:28.599Z","comments":true,"path":"2013-05-21-2013-05-21-min-mmap-addr.html","link":"","permalink":"http://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html","excerpt":"","text":"我们的项目比较特殊，需要在x86机器上mmap小于0x10000的虚地址。然而在默认的x86 Linux上，小于0x10000的虚地址是没有办法mmap的。而x86 Linux不让用户mmap低于0x10000的虚地址也是有它的道理的。 有时候因为某些设计缺陷，程序使用了错误的指针，访问了错误的内存。如果指针指向的地址在进程中没有被映射，那么执行时会产生page fault异常，操作系统会给进程发送SIGSEGV信号。如果程序没有注册SIGSEGV信号处理函数，接收到这个信号就会退出，并报告我们熟悉的’Segmentation Fault’。但是，如果指针指向的地址在进程中被映射了，错误的内存访问就会悄无声息地发生，给debug带来了很大的难度。在设计进程的虚拟空间的时候，x86 Linux不让用户mmap低于0x10000的虚地址空间，那么这段空间永远不会被映射，所有非法访问这段内存的行为都会被发现，为程序debug带来了一些便利。 其实，在不同的Linux系统下，默认可以mmap的最低地址是不同的。比如x86上是0x10000，mips上是0x4000，arm上是0x1000。 下面这个小程序能够输出当前系统下可以mmap的最低地址： mmap.c12345678910111213141516171819#include &lt;sys/mman.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; int i; void *start = NULL; size_t page_size = getpagesize(); while(1)&#123; void *addr = mmap(start, page_size, PROT_READ|PROT_WRITE, \\ MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0); if(addr != MAP_FAILED) &#123; printf(&quot;lowest mapable address: %p\\n&quot;, start); break; &#125; start += page_size; &#125; return 0;&#125; 我们的项目必须要能够在x86 Linux中mmap 0x1000到0x10000这段地址，经过一番摸索，我终于找到了解决办法。Linux Kernel中有一个参数mmap_min_addr控制着mmap能够映射的最低内存地址，而这个参数能够通过/proc/sys/vm/mmap_min_addr这个文件[1]来进行读写。系统中的任何用户都可以读这个文件，但只有root用户能够写这个文件。 1# echo 4096 &gt; /proc/sys/vm/mmap_min_addr 执行完这条命令之后，再用上面的小程序测试可以mmap的最低地址就变成了0x1000，实现了我们的需求。 在重新启动Linux之后，mmap_min_addr就会重新被设置为默认值。要想永久改变mmap_min_addr的值，可以在/etc/sysctl.conf中添加一行 1vm.mmap_min_addr &#x3D; 4096 [1] 其实这个文件是一种特殊的文件，其文件大小为0，读取文件内容时，系统调用read会触发内核中的代码自动生成内容填写给用户态buffer中。写文件内容时，系统调用write会触发内核中的代码自动从用户态buffer读取内容，设置相应的内核数据。内核模块的参数也可以通过这种文件的方式来读取和设置。","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[]},{"title":"-pie和-fPIE选项","slug":"2013-05-21-pie","date":"2013-05-21T12:49:00.000Z","updated":"2020-08-11T06:56:28.600Z","comments":true,"path":"2013-05-21-2013-05-21-pie.html","link":"","permalink":"http://richardustc.github.io/2013-05-21-2013-05-21-pie.html","excerpt":"","text":"位置无关可执行程序是一种比较有趣的程序。这种程序像动态库一样，可以自由加载到内存中任意合适的位置执行。 linux下，最著名的位置无关可执行程序就是/lib/ld-linux.so.2(32位Linux)或/lib64/ld-linux-x86-64.so.2(64位x86 Linux)了。以64位x86机器为例，所有的64位动态连接程序都依赖/lib64/ld-linux-x86-64.so.2, 而/lib64/ld-linux-x86-64.so.2本身也是一个可执行程序。 123$ /lib64/ld-linux-x86-64.so.2 Usage: ld.so [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]... 要使用gcc编译出位置无关可执行程序，必须使用-pie和-fPIE选项。其中，-fPIE选项用于编译器，使用这个选项之后，从.c或.cpp编译出来的.o文件将是位置无关的目标文件。而-pie选项则用于链接器，使用这个选项之后，链接器能够把-fPIE选项下编译出来的.o文件链接成位置无关可执行程序。 下面是一个简单的示例。hello.c源文件： hello.c123456789#include &lt;stdio.h&gt;void print_hello(void)&#123; printf(&quot;Hello.\\n&quot;);&#125;int main(int argc, char *argv[]) &#123; print_hello(); return 0;&#125; 编译hello.c源文件： 12gcc -fPIE -pie hello.c -o hello_piegcc hello.c -o hello 运行hello和hello_pie： 1234$ ./hello_pie Hello.$ ./helloHello. 利用file命令查看hello和hello_pie： 1234$ file hello_pie hello_pie: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped$ file hellohello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped 可以看出hello_pie是”shared object”，而hello是”executable”。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[]},{"title":"Add a New CPU Model for Gem5","slug":"2013-05-21-add-new-cpu-model-for-gem5","date":"2013-05-21T04:10:00.000Z","updated":"2020-08-11T06:56:28.599Z","comments":true,"path":"2013-05-21-2013-05-21-add-new-cpu-model-for-gem5.html","link":"","permalink":"http://richardustc.github.io/2013-05-21-2013-05-21-add-new-cpu-model-for-gem5.html","excerpt":"","text":"IntroductionGem5 is a simulator system, which can support several kinds of ISA and several kinds of CPU. The documentation of “Adding a New CPU Model” is out of date. I tried to update the documentation, but the update has not been approved yet. So, I decide to write down the procedures in my own blog. Some of the procedures are based the old documentation. OverviewFirst, make sure you have basic understanding of how the CPU models function within the M5 framework. A good start is the CPU Models page. This brief tutorial will show you how to create a custom CPU model called ‘MyCPU’, which will just be a renamed version of the AtomicSimpleCPU. After you learn how to compile and build ‘MyCPU’, then you have the liberty to edit the ‘MyCPU’ code at your heart’s content without worrying about breaking any existing M5 CPU Models. Port C++ Code for MyCPUThe easiest way is to derive a new C++ class of your CPU Model from M5 CPU Models that are already defined and the easiest model to start with is the ‘AtomicSimpleCPU’ located in the ‘gem5/src/cpu/simple’ directory. For this example, we’ll just copy the files from the ‘gem5/src/cpu/simple’ and place them in our own CPU directory: gem5/src/cpu/mycpu. 12me@mymachine:~/gem5$ cd src/cpume@mymachine:~/gem5/src/cpu$ cp -r simple mycpu Now check the mycpu directory to make sure you’ve copied the files successfully. 1234me@mymachine:~/gem5/src/cpu$ cd mycpu me@mymachine:~/gem5/src/cpu/mycpu$ lsAtomicSimpleCPU.py BaseSimpleCPU.py SConscript SConsopts TimingSimpleCPU.py atomic.cc atomic.hh base.cc base.hh timing.cc timing.hh Let’s remove the files TimingSimpleCPU.py, timing.cc and timing.hh. We don’t need them. 123me@mymachine:~/gem5/src/cpu/mycpu$ rm TimingSimpleCPU.py timing.cc timing.hhme@mymachine:~/gem5/src/cpu/mycpu$ lsBaseSimpleCPU.py AtomicSimpleCPU.py SConscript SConsopts atomic.cc atomic.hh base.cc base.hh Since we want to change ‘AtomicSimpleCPU’ to ‘MyCPU’, we will just replace all the names in the AtomicSimpleCPU.py, atomic.* files and name them MyCPU.py, mycpu.* files. We don’t need AtomicSimpleCPU.py, atomic.cc and atomic.hh any more, so we will remove them. 123456me@mymachine:~/gem5/src/cpu/mycpu$ for file in *; do perl -pe s/AtomicSimpleCPU/MyCPU/g $file &gt; $file.tmp; mv $file.tmp $file; doneme@mymachine:~/gem5/src/cpu/mycpu$ mv AtomicSimpleCPU.py MyCPU.pyme@mymachine:~/gem5/src/cpu/mycpu$ mv atomic.cc mycpu.ccme@mymachine:~/gem5/src/cpu/mycpu$ mv atomic.hh mycpu.hhme@mymachine:~/gem5/src/cpu/mycpu$ lsBaseSimpleCPU.py MyCPU.py SConscript SConsopts base.cc base.hh mycpu.hh mycpu.cc We also need to change ‘BaseSimpleCPU’ to ‘BaseMyCPU’, or we will have duplicated definition of ‘BaseSimpleCPU’ when compiling. 12me@mymachine:~/gem5/src/cpu/mycpu$ for file in *; do perl -pe s/BaseSimpleCPU/BaseMyCPU/g $file &gt; $file.tmp; mv $file.tmp $file; doneme@mymachine:~/gem5/src/cpu/mycpu$ mv BaseSimpleCPU.py BaseMyCPU.py Next, you need to edit all your files to only include files in ‘mycpu’ directory instead of ‘simple’ directory. We also need to replace ‘atomic.hh’ to ‘mycpu.hh’ in mycpu.cc file. 12me@mymachine:~/gem5/src/cpu/mycpu$ for file in *; do perl -pe s/atomic\\.hh/mycpu\\.hh/g $file &gt;$file.tmp; mv $file.tmp $file; doneme@mymachine:~/gem5/src/cpu/mycpu$ for file in *; do perl -pe s#/simple/#/mycpu/#g $file &gt; $file.tmp; mv $file.tmp $file; done Next, you need to comment out the function ‘change_thread_state’ from base.cc, or there will be duplicated definition of ‘change_thread_state’ when compiling. 1me@mymachine:~/gem5/src/cpu/mycpu$ vim base.cc NOTE: The AtomicSimpleCPU is really just based off the BaseSimpleCPU (src/cpu/simple/base.hh) so your new CPU Model MyCPU is really a derivation off of this CPU model. Additionally, the BaseSimpleCPU model is derived from the BaseCPU (src/cpu/base.hh). As you can see, M5 is heavily object oriented. Making M5 Recognize MyCPUNow that you’ve created a separate directory and files for your MyCPU code (i.e. gem5/src/cpu/mycpu), there are a couple files that need to be updated so that M5 can recognize MyCPU as a build option. gem5/src/cpu/mycpu/SConscript: Edit the SConscript for your CPU model and add the relevant files that need to be built in here. Your file should only contain this code. SConscript12345678Import(&#x27;*&#x27;)if &#x27;MyCPU&#x27; in env[&#x27;CPU_MODELS&#x27;]: SimObject(&#x27;MyCPU.py&#x27;) Source(&#x27;mycpu.cc&#x27;) DebugFlag(&#x27;MyCPU&#x27;) Source(&#x27;base.cc&#x27;) SimObject(&#x27;BaseMyCPU.py&#x27;) gem5/src/cpu/mycpu/SConsopts: Edit the SConscript for your CPU model and add in CPU Model-specific information for the ISA Parser. The ISA Parser will use this when referring to the “Execution Context” for executing instructions. For instance, the AtomicSimpleCPU’s instructions get all of their information from the actual CPU (since it’s a 1 CPI machine). Thus, instructions only need to know the current state or “Execution Context” of the ‘AtomicSimpleCPU’ object. However, the instructions in a O3CPU needed to know the register values (&amp; other state) only known to that current instruction so it’s “Execution Context” is the O3DynInst object. (check out the ISA Description Language documentation page for more details). Your file should only contain this code: SConsopts1234567Import(&#x27;*&#x27;)CpuModel(&#x27;MyCPU&#x27;, &#x27;my_cpu_exec.cc&#x27;, &#x27;#include &quot;cpu/mycpu/mycpu.hh&quot;&#x27;, &#123; &#x27;CPU_exec_context&#x27;: &#x27;MyCPU&#x27; &#125;, default=True) gem5/src/cpu/static_inst.hh: Put a forward class declaration of your model in here static_inst.hh12345678...class CheckerCPU;class FastCPU;class AtomicSimpleCPU;class TimingSimpleCPU;class InorderCPU;class MyCPU;... You alse need to add ‘MyCPU’ to ‘CPU_MODELS’ so that it will be compiled latter. Navigate to the ‘build_opts’ directory. 12me@mymachine:~/gem5/src/python/objects$ cd ~/gem5/build_optsme@mymachine:~/gem5/build_opts$ for file in *;do perl -pe s/AtomicSimpleCPU/AtomicSimpleCPU,MyCPU/g $file &gt; $file.tmp; mv $file.tmp $file; done Building MyCPUBefore building your cpu model, you need to make sure you have all the needed tools installed. See Dependencies page for details.Navigate to the M5 top-level directory and build your model: 1234567891011121314151617181920me@mymachine:~/gem5/src/python/objects$ cd ~/gem5me@mymachine:~/gem5$ scons build/MIPS/gem5.debugscons: Reading SConscript files ...Checking for leading underscore in global variables...(cached) noChecking for C header file Python.h... (cached) yesChecking for C library pthread... (cached) yesChecking for C library dl... (cached) yesChecking for C library util... (cached) yesChecking for C library m... (cached) yesChecking for C library python2.7... (cached) yesChecking for accept(0,0,0) in C++ library None... (cached) yesChecking for zlibVersion() in C++ library z... (cached) yesChecking for clock_nanosleep(0,0,NULL,NULL) in C library None... (cached) no... [ RANLIB] -&gt; libelf/libelf.a [ SHCXX] gzstream/gzstream.cc -&gt; .os [ AR] -&gt; gzstream/libgzstream.a [ RANLIB] -&gt; gzstream/libgzstream.a [ LINK] -&gt; MIPS/gem5.debugscons: done building targets. If you are compiling on a dual-core CPU, use this command-line to speed-up the compilation: 1scons -j2 build/MIPS/gem5.debug Creating Configuration Scripts for MyCPUNow that you have a M5 binary built for use with the MIPS Architecture in a M5 MyCPU Model, you are almost ready to simulate. Note that the standard M5 command line requires that you provide at least a configuration script for the M5 binary to use. The easiest way to get up and running is to use the sample Syscall-Emulation script: configs/example/se.py. You’ll note that line 9 of the se.py Python script imports the details of what type of Simulation will be run (e.g. what CPU Model?) from the Simulation.py file found here:gem5/configs/common/Simulation.py. And then, the Simulation.py file imports it’s CPU Model options from the Options.py file in the same directory. Edit those two files and your M5 binary will be ready to simulate. gem5/configs/common/Options.py: Add ‘mycpu’ to the cpu_type list… Options.py123456... parser.add_option(&quot;--cpu-type&quot;, type=&quot;choice&quot;, default=&quot;atomic&quot;, choices = [&quot;atomic&quot;, &quot;timing&quot;, &quot;mycpu&quot;, &quot;detailed&quot;, &quot;inorder&quot;, &quot;arm_detailed&quot;], help = &quot;type of cpu to run with&quot;)... gem5/configs/common/Simulation.py: Edit the Simulation script to recognize your model as a CPU class. After your edits, the setCPUClass function should look like this: Simulation.py123456789101112131415...def setCPUClass(options):... elif options.cpu_type == &quot;inorder&quot;: if not options.caches: print &quot;InOrder CPU must be used with caches&quot; sys.exit(1) class TmpClass(InOrderCPU): pass elif options.cpu_type == &quot;mycpu&quot;: class TmpClass(MyCPU):pass atomic = True else: class TmpClass(AtomicSimpleCPU): pass atomic = True... Testing MyCPUOnce you’ve edited the configuration scripts, you can run a M5 simulation from the top level directory with this command line: 1234567891011121314151617me@mymachine:~/gem5$ ./build/MIPS/gem5.debug configs/example/se.py --cpu-type mycpu --cmd tests/test-progs/hello/bin/mips/linux/hellogem5 Simulator System. http://gem5.orggem5 is copyrighted software; use the --copyright option for details.gem5 compiled May 17 2013 20:17:23gem5 started May 17 2013 20:22:42gem5 executing on servercommand line: ./build/MIPS/gem5.debug ./configs/example/se.py --cpu-type mycpu --cmd tests/test-progs/hello/bin/mips/linux/helloGlobal frequency set at 1000000000000 ticks per secondwarn: CoherentBus system.membus has no snooping ports attached!0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000**** REAL SIMULATION ****info: Entering event queue @ 0. Starting simulation...info: Increasing stack size by one page.Hello World!hack: be nice to actually delete the event hereExiting @ tick 2913500 because target called exit() NOTE: This binary path refers to the gem5/tests directory. SummarySo the above “tutorial” showed you how to build your own CPU model in M5. Now, it’s up to you to customize the CPU Model as you like and do your experiments! Good luck!","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[]},{"title":"Git SVN","slug":"2013-05-20-git-svn","date":"2013-05-20T03:13:00.000Z","updated":"2020-08-11T06:56:28.598Z","comments":true,"path":"2013-05-20-2013-05-20-git-svn.html","link":"","permalink":"http://richardustc.github.io/2013-05-20-2013-05-20-git-svn.html","excerpt":"","text":"目前有很多项目使用了svn。为了利用git的优势，可以使用git svn系列命令来实现git与svn的结合。详细的资料可以参考git svn教程。 从svn仓库中取出数据。 1git svn clone &lt;svn-repo&gt; &lt;repo-name&gt; 向svn仓库中推送本地的更改。注意：需要先用git commit提交本地更改到本地仓库。 1git svn dcommit -m &quot;comment&quot; 获取svn仓库中的更改，和本地内容进行合并 1git svn rebase 查看svn式的log 1git svn log 此外，在本地仓库中的分支内容的合并最好不要直接merge，而是rebase。因为使用merge方式合并，代码提交历史不是线性的，提交到svn仓库之后，源分支的提交历史信息就丢失了。 有时候，不希望svn代码仓库中包含.gitignore文件。这时候，可以将需要写在.gitignore目录中的规则写在$GIT_DIR/info/exclude文件中，通常$GIT_DIR就是./.git。这个exclude文件仅作用于当前的本地仓库，并且不会被提交到svn仓库中。","categories":[{"name":"Git","slug":"Git","permalink":"http://richardustc.github.io/categories/Git/"}],"tags":[]},{"title":"Git Submodules","slug":"2013-05-19-git-submodules","date":"2013-05-19T13:22:00.000Z","updated":"2020-08-11T06:56:28.598Z","comments":true,"path":"2013-05-19-2013-05-19-git-submodules.html","link":"","permalink":"http://richardustc.github.io/2013-05-19-2013-05-19-git-submodules.html","excerpt":"","text":"有时候，一个项目可能需要使用一些外部的源码，或者多个项目共享一部分相对独立的代码。这个时候，不适宜直接把这些外部源码或者共享的源码包含在当前项目的源码中，最好能够独立管理它们。而git的submodule就正好提供了这个功能。这里举一个简单的示例。 假设当前项目名为project_a，需要使用一个独立的project_b的代码。假设project_a和project_b的代码仓库都已经创建好。可以这样初始化： 123git clone &lt;project_a-repo&gt; acd agit submodule add &lt;project_b-repo&gt; b 这时，在目录a下就会生成一个.gitmodules的文件，文件内容为： 123[submodule &quot;b&quot;] path &#x3D; b url &#x3D; &lt;project_b-repo&gt; 同时目录a下会生成一个目录b，其中包含的正是project_b的内容。添加需要提交的文件之后，使用git commit提交更改，使用push将project_a的更改推送到上。现在，我们再在另外一个位置clone出，查看添加submodule的效果。 12git clone &lt;project_a-repo&gt; acd a 在目录a下可以发现有一个目录b，但是目录中还没有project_b的内容。现在可以用下面的命令来获取project_b的内容。 12git submodule initgit submodule update 命令执行完成之后，project_b的内容就clone到目录b下了。 此时需要注意的是，每次git submodule update执行完之后，目录b中的working tree没有指向任何的branch，需要自己使用git checkout切换到已有的分支上，否则所做修改可能丢失。 以后，当project_b的内容发生变化之后，在目录b下用git pull或git fetch就可以获取project_b的变化了。需要注意的是，当目录b改变之后，需要先将目录b提交之后，才能提交目录a的更改。","categories":[{"name":"Git","slug":"Git","permalink":"http://richardustc.github.io/categories/Git/"}],"tags":[]},{"title":"Find","slug":"2013-05-17-find","date":"2013-05-17T14:38:00.000Z","updated":"2020-08-11T06:56:28.597Z","comments":true,"path":"2013-05-17-2013-05-17-find.html","link":"","permalink":"http://richardustc.github.io/2013-05-17-2013-05-17-find.html","excerpt":"","text":"find 命令在Linux中的应用非常广泛，以前我对find命令不是很熟悉。今天刚好用到了这条命令，就顺便记录一下。 find.sh123456find &lt;path&gt; -name &#x27;&lt;file-name&gt;&#x27;find &lt;path&gt; -name &#x27;&lt;file-name&gt;&#x27; -exec &lt;command&gt; &#123;&#125; \\;find &lt;path&gt; -name &#x27;&lt;file-name&gt;&#x27; -ok &lt;command&gt; &#123;&#125; \\;find &lt;path&gt; -regex &#x27;&lt;reg-expression&gt;&#x27;find &lt;path&gt; -regex &#x27;&lt;reg-expression&gt;&#x27; -exec &lt;command&gt; &#123;&#125; \\;find &lt;path&gt; -regex &#x27;&lt;reg-expression&gt;&#x27; -ok &lt;command&gt; &#123;&#125; \\;","categories":[{"name":"Command-Line","slug":"Command-Line","permalink":"http://richardustc.github.io/categories/Command-Line/"}],"tags":[]},{"title":"Git Basics","slug":"2013-05-15-git-basics","date":"2013-05-15T13:15:00.000Z","updated":"2020-08-11T06:56:28.597Z","comments":true,"path":"2013-05-15-2013-05-15-git-basics.html","link":"","permalink":"http://richardustc.github.io/2013-05-15-2013-05-15-git-basics.html","excerpt":"","text":"Git是Linus Torvalds领导开发的分布式版本管理系统，也是世界上最流行的分布式版本管理系统。关于Git，这里有一本非常好的学习资料[中文版][progit-chinese]和[英文版][progit-english]。下面是最常用的一些命令。 Init12345# init a repository with working treegit init# init a repository without working treegit init --bare Clone12345# clone from an existing repositorygit clone &lt;uri&gt;# clone from an existing repository and rename it to &#39;repo-name&#39;git clone &lt;uri&gt; &lt;repo-name&gt; Add12345678# add a file &#39;file&#39; to staging areagit add &lt;file&gt;# add all files under directory &#39;dir&#39; to staging areagit add &lt;dir&gt;&#x2F;*# recursively add all files under current diretory to staging areagit add . Status123# get the status of current working treegit status Commit12345# commit changes of the working tree in the staging area to local repositorygit commit -m &quot;&lt;some comments&gt;&quot;# reset the last commit and apply changes of the staging area and then commit it againgit commit --amend Log12345678# show commit historygit log# show last &lt;num&gt; historygit log -&lt;num&gt;# show branching graph with historygit log --graph Remove12# remove file from working tree and mark it as removed in staging areagit rm &lt;file&gt; Reset12# reverse to &#39;git add &lt;file&gt;&#39;, move the changes of &#39;file&#39; out of staging areagit reset &lt;file&gt; Revert12345# drop all changes of &#39;file&#39; after last commitgit checkout -- &lt;file&gt;&#96;&#96;&#96; ## Branch create a branch ‘new-branch’git branch switch to a branch ‘branch’git checkout create and switch to a branch ‘new-branch’git checkout -b 12## Merge merge branch ‘other-branch’ to current branchgit merge 12## Stash push the current staging area to a stackgit stash list the stackgit stash list pop the top of stackgit stash pop get the ‘num’th item in the stack and remove it from the stackgit stash pop stash@{} 12## Tag set a simple tag ‘tag-name’git tag set a annotated tag ‘tag-name’git tag -a -m ““ show all tagsgit tag delete a taggit tag -d 12## Remote add a remote repository, and set its name ‘remote-repo’git remote add remove a remote repository ‘remote-repo’git remote rm show remote repositoriesgit remote show detailed information of remote repositoriesgit remote -v rename a remote namegit remote rename set local branch ‘local-branch’ track remote branch ‘remote-branch’git checkout –track / create a new local branch and track remote branch ‘remote-branch’git checkout -b / 12## Push push local repository branch ‘local-branch’ to remote repository ‘remote-repo’ branch ‘remote-branch’git push : if the local branch and remote branch are of the same name ‘branch-name’git push delete a remote branch ‘remote-branch’git push : 12## Pull fetch content of ‘remote’ and merge it with current branchgit pull [progit-chinese]: http://git-scm.com/book/zh/ [progit-english]: http://git-scm.com/book","categories":[{"name":"Git","slug":"Git","permalink":"http://richardustc.github.io/categories/Git/"}],"tags":[]},{"title":"Crosstool-ng Notes","slug":"2013-05-15-crosstool-ng-notes","date":"2013-05-15T03:14:00.000Z","updated":"2020-08-11T06:56:28.596Z","comments":true,"path":"2013-05-15-2013-05-15-crosstool-ng-notes.html","link":"","permalink":"http://richardustc.github.io/2013-05-15-2013-05-15-crosstool-ng-notes.html","excerpt":"","text":"最近的项目需要在x86的机器上编译一些arm程序，而之前编译好的arm交叉编译器要么是Android专用的，要么对内核版本的要求比较高，静态编译出来的程序在较低版本的内核上没法运行。所以今天就再用crosstool-ng重新编译了一次工具链。 crosstool-ng是一个用于构建交叉编译器的工具，替代了以前的crosstool，而且这个项目目前还处于比较活跃的状态中。目前最新的版本是2013-01-31发布的1.18.0版本。crosstool-ng官方网站 在Google里搜索crosstools-ng，第二条就会出现一些教程，但是这些教程已经比较老了。一些源码包的版本号跟博主当时的需求相关紧密，并不适用于我的情况。于是，我就到crosstool-ng官网下载了源码包，自己一步步看自带的说明文档。crosstool-ng的源码包中的文档位于doc目录，里面的讲解非常详细，按照步骤一步一步做下来基本上没有什么障碍。不过，还是有一些小技巧可以和大家分享分享。 crosstool-ng 1.18.0版已经可以通过基于ncurses的图形菜单来配置了。首先根据doc中的说明，安装好ct-ng。然后ct-ng menuconfig就可以启用图形菜单了。不过需要注意的是，最好每一项都确认一下，因为默认的设置并不一定适合你的需求。 crosstool-ng默认使用的软件包下载源比较慢，可以设置使用镜像网站。设置方法：Path and misc options–&gt;Use a mirror，然后更改默认的http://crosstool-ng.org/mirrors 为 http://mirrors.ustc.edu.cn/gnu 。大部分的软件源码包都可以在这个源下下载到。另外，linux-kernel的源码包也可以在http://mirrors.ustc.edu.cn/linux-kernel目录下去下载。在此，特别感谢USTC(中国科学技术大学)和USTC LUG。 为了避免静态编译出来的程序在较老的内核上报’kernel too old’的错，可以在Operating Syste–&gt;Target OS选则Linux，然后再选择Linux kernel version。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[]},{"title":"Python Basic Data Types","slug":"2013-05-14-python-basic-data-types","date":"2013-05-14T13:21:00.000Z","updated":"2020-08-11T06:56:28.595Z","comments":true,"path":"2013-05-14-2013-05-14-python-basic-data-types.html","link":"","permalink":"http://richardustc.github.io/2013-05-14-2013-05-14-python-basic-data-types.html","excerpt":"","text":"Python的基本数据结构主要包括Tuple、List、Dict、Set。 Tupletuple.py12345t = ()t = tuple()t = (1,2,3)print t[0]t[-1] # equalvalent to t[len(t)-1] Tuple中的元素一旦创建之后就不能改变，不能增加，不能减少，不能删除。 Listlist.py12345678l = []l = list()l = [1,2,3]l.append(4)l[5] = 5del(l[0])print l[0]item = l.pop() List中的元素创建之后还可以改变，可以增加，可以减少，可以删除。 Dictdict.py1234567d = &#123;&#125;d = dict()d = &#123;&quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot;:&quot;v2&quot;&#125;d[&quot;k3&quot;] = &quot;v3&quot;print d[&quot;k1&quot;]print d.get(&quot;k1&quot;, &quot;if k1 not found, return this value&quot;)key, value = d.pop() Dict用来保存key-value对。其中key必须是immutable的。 Setset.py1234s = set()s.add(2)s.add(2) # After this operation, only one &#x27;2&#x27; is storeditem = s.pop() # return an arbitrary value of the set Set中的元素是唯一的。 SliceTuple和List支持slice。 slice.py12345678t = (0,1,2,3)t[:] # the whole tuplet[0:2] # t[0], t[1]t[:2] # same as t[0:2]t[2:] # same as t[2:len(t)-1]t[-1:] # reversed t# The same goes for list","categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"}],"tags":[]},{"title":"Python Module","slug":"2013-05-14-python-module","date":"2013-05-14T11:53:00.000Z","updated":"2020-08-11T06:56:28.596Z","comments":true,"path":"2013-05-14-2013-05-14-python-module.html","link":"","permalink":"http://richardustc.github.io/2013-05-14-2013-05-14-python-module.html","excerpt":"","text":"Python中，module是用来组织代码的有效方法。 导入模块import-module.py1234567import sysfrom os import pathimport xml.dom.minidom as minidomprint sys.argv[0]path.exists(&quot;test.txt&quot;)d = minidom.parse(&quot;test.xml&quot;) 判断模块代码是直接运行还是被导入check-how-module-is-running.py1234if __name__ == &quot;__main__&quot;: print &quot;module is running directly&quot;else: print &quot;module is imported by another module&quot; 模块搜索路径导入模块的时候，python首先会在内置模块中查找，如果找不到，则会到sys.path中指定的路径中去找。sys.path包含这些内容： 当前目录 PYTHONPATH PYTHONPATH类似于PATH，包含一系列的目录 其他的一些跟安装相关的默认路径当前目录的优先级比标准库的优先级更高。Python程序在运行的过程中可以修改sys.path的值，从而影响模块的导入。 创建自己的模块比如我自己写了一个模块，叫做mymoudle.py。 如果在同一个目录下，直接import mymodule即可。 如果相对路径为mymodule/mymodule.py，则需要在mymodule目录下创建__init__.py文件，然后import mymodule.mymodule。 如果相对路径为mymodule/mymodule/mymodule.py，则需要在两个目录中都创建__init__.py文件，然后import mymodule.mymodule.mymodule。 其他 使用dir可以查看module中所有可用的变量、类和函数等信息 当模块被import之后，在模块py文件所在目录会生成.pyc文件。这个文件的内容和格式可参考这篇文章","categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"}],"tags":[]},{"title":"Python Basics","slug":"2013-05-14-python-basics","date":"2013-05-14T11:23:00.000Z","updated":"2020-08-11T06:56:28.595Z","comments":true,"path":"2013-05-14-2013-05-14-python-basics.html","link":"","permalink":"http://richardustc.github.io/2013-05-14-2013-05-14-python-basics.html","excerpt":"","text":"最近在复习Python，顺便记录一下自己的复习笔记，以后可以再回来看看。 Hello Worldhello-world.py12if __name__ == &quot;__main__&quot;: print &quot;Hello, World.&quot; 分支branch.py123456if x==y: do_x_equal_y_stuff()elif x==z: do_x_equal_z_stuff()else: do_other_stuff() 循环for-loop.py123456789for i in range(5): print i if i == j: break if i == k: continueelse: # do something if the loop end normally do_some_stuff() while-loop.py12345678910while x&gt;0: x-- print x if x == j: break if x == k: continueelse: #do something if the loop end normally do_some_stuff() 函数simple-function.py123456def add(a,b): &#x27;&#x27;&#x27; return the result of a plus b&#x27;&#x27;&#x27; # docstring, need to be at the first line of the function return a+b#call the functionprint add(1,3) local-global.py1234567891011x=10 # Here, x is globaldef foo(): x = 50 # Here, x is local, does not affect the global xdef bar(): global x x= 8 # Here, x is global# testfoo()print xbar()print x default-parameters.py1234567def add(a, b, c=0, d=3): return a+b+c+d#call the functionprint add(1, 3)print add(1, 3, 4)print add(1, 3, d=2) list-and-dict-parameters.py123456789def foo(a, *l, **d): print a for list_item in l: print list_item for key,value in d: print &quot;&#123;k&#125;:&#123;v&#125;&quot;.format(k=key, v=value)# testfoo(1, [&quot;x&quot;,&quot;y&quot;], &#123;&quot;key&quot;: &quot;value&quot;&#125;) 类12345678910111213141516__metaclass__ = type # new-style classclass ClassName(Parent1, Parent2): classVar = 0 def __init__(self, parameter): super(ClassName, self).__init__(parameter) self.__class__.classVar += 1 self.objectVar = 0 pass def method(self, parameter): pass @classmethod def classMethod(cls, parameter): pass @staticmethod def staticMethod(parameter): pass 迭代器12345678910111213__metaclass__ = typeclass Fib: def __init__(self): self.first = 1 self.second = 1 def __iter__(self): return self # a iterator returns a object which implements the &#x27;next&#x27; method def next(self): # if there is no next item, raise &#x27;StopIteration&#x27; exception ret = self.first tmp = self.second self.second = self.second + self.first self.first = tmp return ret 生成器123def generator(l): for item in l: yield item 异常12345678910111213141516171819202122import exceptions #standard exceptionsdef foo(parameters): try: # do something if someCondition : raise SomeError if someOtherCondition: raise someErrorObject # do something except SomeError: raise # raise the exception again except (SomeError1, SomeError2): # catch two types of exceptions at the same site # do something except (SomeError3), errorObject: # do something with errorObject except: # catch all exceptions else: # do something if no exception is raised finally: # do something whether there is any exception or not","categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"}],"tags":[]},{"title":"从CNBlog迁移到Github","slug":"2013-05-11-migration","date":"2013-05-11T12:13:00.000Z","updated":"2020-08-11T06:56:28.594Z","comments":true,"path":"2013-05-11-2013-05-11-migration.html","link":"","permalink":"http://richardustc.github.io/2013-05-11-2013-05-11-migration.html","excerpt":"","text":"我是从CNBlog迁移过来，所以需要将CNBlog的文章导入到新的博客中。 jekyll支持从多种别的博客平台迁移到当前平台，但是没有支持CNBlog，于是我不得不自己来完成这个博客导入的过程。 CNBlog的文章备份出来的是一个xml文件。我分析了这个文件之后，写了一个python脚本，完成从xml到markdown的转换。我的脚本号称转换成了markdown，其实只是增加了一个yaml front matter，内容部分仍然是原来的html。不过就效果来看，还马马虎虎可以接受，就不再继续折腾了。 脚本特点： 保留了原来的发表日期 保留了原来的标题，但是因为octopress对文件名为中文的文件支持不好，所以文件名改为了-blog-的形式 支持在转换的过程中指定分类 支持转换输出为html或者octopress使用的markdown格式 这个python脚本已经上传的github上了，这个是github链接，欢迎大家批评指正。","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[]},{"title":"Welcome","slug":"2013-05-10-welcome","date":"2013-05-10T07:06:00.000Z","updated":"2020-08-11T06:56:28.594Z","comments":true,"path":"2013-05-10-2013-05-10-welcome.html","link":"","permalink":"http://richardustc.github.io/2013-05-10-2013-05-10-welcome.html","excerpt":"","text":"欢迎访问我的github博客 我原来的博客位于CNBlog，最近发现octopress的博客比较清爽，而且可以利用github提供的Github Pages功能，于是就迁移到了这里。","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[],"author":"RichardUSTC"},{"title":"截获Linux操作系统异常处理","slug":"2013-05-03-blog-0","date":"2013-05-03T04:05:00.000Z","updated":"2020-08-11T06:56:28.593Z","comments":true,"path":"2013-05-03-2013-05-03-blog-0.html","link":"","permalink":"http://richardustc.github.io/2013-05-03-2013-05-03-blog-0.html","excerpt":"","text":"&nbsp; &nbsp; 在某些情况下，我们可能需要去截获Linux操作系统的一些异常处理，比如截获page fault异常处理。 可以修改内核的情况下 &nbsp; &nbsp; 如果我们能够修改内核，那么截获page fault异常处理就会非常简单。以linux 3.8.0内核为例，系统中发生page fault之后，会进入page fault异常处理，调用do_page_fault函数。do_page_fault的代码如下： 1 dotraplinkage void __kprobes 2 do_page_fault(struct pt_regs *regs, unsigned long error_code) 3 { 4 exception_enter(regs); 5 __do_page_fault(regs, error_code); 6 exception_exit(regs); 7 } &nbsp; &nbsp; 我们把do_page_fault函数的内容提取出来，写成一个新的函数default_do_page_fault。再增加一个函数指针do_page_fault_handler，初始化为default_do_page_fault。将原来的do_page_fault内部改为调用函数指针do_page_fault_handler。修改之后的代码如下： void default_do_page_fault(struct pt_regs *regs, unsigned long error_code) { exception_enter(regs); __do_page_fault(regs, error_code); exception_exit(regs); }EXPORT_SYMBOL(default_do_page_fault); typedef void (*do_page_fault_handler_t)(struct pt_regs *, unsigned long); do_page_fault_handler_t do_page_fault_handler = default_do_page_fault;EXPORT_SYMBOL(do_page_fault_handler); dotraplinkage void __kprobesdo_page_fault(struct pt_regs *regs, unsigned long error_code){ do_page_fault_handler(regs, error_code);} &nbsp; &nbsp; 由于do_page_fault_handler被EXPORT_SYMBOL导出，我们在内核模块中可以很方便地访问它。只要将do_page_fault_handler的值设置为自定义的page fault异常处理函数，就能完成截获功能。如果想要恢复原来的异常处理函数，只需要再次把do_page_fault_handler设置为default_do_page_fault即可。 不能修改内核的情况下 &nbsp; &nbsp;但是有些情况下，我们不能直接修改内核代码，需要在已经编译好的内核上完成截获功能。 &nbsp; &nbsp;开始的时候，我考虑在do_page_fault函数开始处插入跳转代码，跳转到自定义的page fault处理函数中。但是实践的时候发现，内核不允许直接修改do_page_fault的代码。 &nbsp; &nbsp; 经过一番调查，又想到一个新的办法，即通过更改IDT表的方式来截获page fault。 &nbsp; &nbsp; 内核原有的IDT表肯定是不能直接写的，所以我申请了一个页，将原来的IDT表复制过来，再更改页面异常对应的ISR(Interrupt Service Routine)。page fault的ISR名称为page_fault，它将寄存器压栈，将error number压栈，然后调用do_page_fault，待do_page_fault返回之后再恢复寄存器，退出异常处理。 &nbsp; &nbsp; 在Linux内核中，ISR是用汇编写的。例如，x86_64 Linux的ISR源码位于内核源码arch/x86/kernel/entry_64.S中，X86_32的位于arch/x86/kernel/entry_32.S中。如果去读entry_64.S或者entry_32.S，你会发现这两个文件非常复杂，利用了很多的汇编宏和宏定义，无法方便地基于它们写一个自定义的ISR出来。 &nbsp; &nbsp; 我的解决办法是将内核编译出来，反汇编vmlinux.o，然后查找page_fault，找到其汇编代码。下面的汇编代码就是linux-3.8.0 X86_64内核的 1 ffffffff8136f6f0 &lt;page_fault&gt;: 2 ffffffff8136f6f0: 66 66 90 data32 xchg %ax,%ax 3 ffffffff8136f6f3: ff 15 07 0a 2b 00 callq *0x2b0a07(%rip) # ffffffff81620100 &lt;pv_irq_ops+0x30&gt; 4 ffffffff8136f6f9: 48 83 ec 78 sub $0x78,%rsp 5 ffffffff8136f6fd: e8 ae 01 00 00 callq ffffffff8136f8b0 &lt;error_entry&gt; 6 ffffffff8136f702: 48 89 e7 mov %rsp,%rdi 7 ffffffff8136f705: 48 8b 74 24 78 mov 0x78(%rsp),%rsi 8 ffffffff8136f70a: 48 c7 44 24 78 ff ff movq $0xffffffffffffffff,0x78(%rsp) 9 ffffffff8136f711: ff ff 10 ffffffff8136f713: e8 1f 2e 00 00 callq ffffffff81372537 &lt;do_page_fault&gt; 11 ffffffff8136f718: e9 33 02 00 00 jmpq ffffffff8136f950 &lt;error_exit&gt; 12 ffffffff8136f71d: 0f 1f 00 nopl (%rax) 我仿照着写了一个，名为my_page_fault 1 asmlinkage void my_page_fault(void); 2 asm(\" .text\"); 3 asm(\" .type my_page_fault,@function\"); 4 asm(\"my_page_fault:\"); 5 //the first 3 bytes of the routine basically do nothing, 6 //but I decide to keep them because kernel may rely on them for some special purpose 7 asm(\" .byte 0x66\"); 8 asm(\" xchg %ax, %ax\"); 9 asm(\" callq *addr_adjust_exception_frame\"); 10 asm(\" sub $0x78, %rsp\"); 11 asm(\" callq *addr_error_entry\"); 12 asm(\" mov %rsp, %rdi\"); 13 asm(\" mov 0x78(%rsp), %rsi\"); 14 asm(\" movq $0xffffffffffffffff, 0x78(%rsp)\"); 15 asm(\" callq my_do_page_fault\"); 16 asm(\" jmpq *addr_error_exit\"); 17 asm(\" nopl (%rax)\"); 其中第9行addr_adjust_exception_frame是(pv_irq_ops+0x30)地址处存储的值；第11行addr_error_entry是error_entry的地址；第16行addr_error_exit是error_exit的地址。这几个值需要从System.map文件中查询，然后用内核模块参数的形式传入。而my_do_page_fault则是我们自己定义的page fault处理函数。 &nbsp; &nbsp; 如果需要截获X86_32的page fault，可以参考这个C文件。不过需要注意的是，新版内核有所变动，这里的代码需要根据自己的情况做一些调整。 &nbsp; &nbsp; 有了自定义的ISR之后，就可以将这个ISR填到IDT中，加载新的IDT表之后，自定义的page fault处理函数就开始发挥作用了。这个过程主要有以下几个步骤： 用store_idt(&amp;default_idtr)保存现有的IDT寄存器值 从default_idtr中读出IDT表首地址和表的大小 申请一个页面 将原来的idt表拷贝到新申请的页面中 利用pack_gate将my_page_fault（注意不是my_do_page_fault）填入到对应的IDT项中 在idtr中填写新的IDT表地址和大小，用load_idt(&amp;idtr)加载新的IDT表到当前CPU 利用smp_call_function，将新的IDT表加载到其他CPU上。 &nbsp; &nbsp; 如果想恢复原来的IDT表，则用load(&amp;default_idtr)和smp_call_function加载原来的IDT表，释放申请的页面。 &nbsp; &nbsp; 读完文章之后，可以参考我的github中的代码：https://github.com/RichardUSTC/intercept-page-fault-handler &nbsp; &nbsp; 本文链接：http://www.cnblogs.com/richardustc/archive/2013/05/03/3057455.html","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[],"author":"RichardUSTC"},{"title":"利用“.byte”在嵌入式汇编中直接插入机器码","slug":"2013-05-01-blog-1","date":"2013-04-30T19:05:00.000Z","updated":"2020-08-11T06:56:28.593Z","comments":true,"path":"2013-05-01-2013-05-01-blog-1.html","link":"","permalink":"http://richardustc.github.io/2013-05-01-2013-05-01-blog-1.html","excerpt":"","text":"最近做的工作需要截获page_fault异常处理，需要模仿着原来的page fault异常处理例程写一个自己的异常处理例程。这个异常处理例程有一部分是汇编代码写的。反汇编原来的内核，发现这样一条指令 66 66 90 data32 xchg %ax, %ax 但是在汇编中，直接用 asm(\"data32 xchg %ax, %ax); 的方式没有办法编译通过。编译器总是报告：`data32' is not supported in 64 bit system. 而直接 asm(\"xchg %ax, %ax\"); 编译之后的汇编代码则只是66 90。 尝试了不少办法，最终去追踪内核代码，发现可以用这种方式来实现 asm(\".byte 0x66\"); asm(\"xchg %ax, %ax\"); 最终编译出来的代码，果然就是66 66 90。 用这种方法就可以实现直接在嵌入式汇编中硬编码机器码。在某些场合，比如底层机器新增加了指令，而编译器还没有做相应的扩展，使用这种方法可以达到使用新指令的目的。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++嵌套类","slug":"2013-04-26-blog-2","date":"2013-04-26T00:04:00.000Z","updated":"2020-08-11T06:56:28.592Z","comments":true,"path":"2013-04-26-2013-04-26-blog-2.html","link":"","permalink":"http://richardustc.github.io/2013-04-26-2013-04-26-blog-2.html","excerpt":"","text":"C++支持类的嵌套，其语法比较简单。代码是最好的说明。 1 #include &lt;iostream&gt; 2 using namespace std; 3 4 class Outter{ 5 public: 6 int a; 7 static int s; 8 //nested class and enclosing class are independent. 9 class Inner{ 10 public: 11 int b; 12 //nested class can access static members of enclosing class 13 int foo(){ return b + s;} 14 int bar(); 15 }; 16 }; 17 18 int Outter::s = 1; 19 //define a nested class member outside of the class declaration. 20 int Outter::Inner::bar(){ 21 return 0xdeadbeef; 22 } 23 24 int main(){ 25 Outter o; 26 o.a = 0; 27 //if nested class is specified as public, then everyone can use the nested class. 28 //if nested class is specified as protected, then only the enclosing class, 29 //friend of the enclosing class and derived class of the enclosing class can access the nested class. 30 //if the nested class is specified as private, then only the enclosing class 31 //and friend of the enclosing class can access the nested class. 32 Outter::Inner i; 33 i.b = 1; 34 cout&lt;&lt;i.foo()&lt;&lt;endl; 35 cout&lt;&lt;hex&lt;&lt;i.bar()&lt;&lt;endl; 36 return 0; 37 } &nbsp;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"获取Linux内核未导出符号的几种方式","slug":"2013-04-25-blog-3","date":"2013-04-25T06:04:00.000Z","updated":"2020-08-11T06:56:28.592Z","comments":true,"path":"2013-04-25-2013-04-25-blog-3.html","link":"","permalink":"http://richardustc.github.io/2013-04-25-2013-04-25-blog-3.html","excerpt":"","text":"&nbsp; &nbsp; 从Linux内核的2.6某个版本开始，内核引入了导出符号的机制。只有在内核中使用EXPORT_SYMBOL或EXPORT_SYMBOL_GPL导出的符号才能在内核模块中直接使用。然而，内核并没有导出所有的符号。例如，在3.8.0的内核中，do_page_fault就没有被导出。 &nbsp; &nbsp; 而我的内核模块中需要使用do_page_fault，那么有那些方法呢？这些方法分别有什么优劣呢？ &nbsp; &nbsp; 下面以do_page_fault为例，一一进行分析： 修改内核，添加EXPORT_SYMBOL(do_page_fault)或EXPORT_SYMBOL_GPL(do_page_fault)。这种方法适用于可以修改内核的情形。在可以修改内核的情况下，这是最简单的方式。 使用kallsyms_lookup_name读取kallsyms_lookup_name本身也是一个内核符号，如果这个符号被导出了，那么就可以在内核模块中调用kallsyms_lookup_name(\"do_page_fault\")来获得do_page_fault的符号地址。这种方法的局限性在于kallsyms_lookup_name本身不一定被导出。 读取/boot/System.map-&lt;kernel-version&gt;，再使用内核模块参数传入内核模块System.map-&lt;kernel-version&gt;是编译内核时产生的，它里面记录了编译时内核符号的地址。如果能够保证当前使用的内核与System.map-&lt;kernel-version&gt;是一一对应的，那么从System.map-&lt;kernel-version&gt;中读出的符号地址就是正确的。其中，kernel-version可以通过'uname -r'获得。但是这种方法也有局限性，在模块运行的时候，System.map-&lt;kernel-version&gt;文件不一定存在，即使存在也不能保证与当前内核是正确对应的。 读取/proc/kallsyms，再使用内核模块参数传入内核模块/proc/kallsyms是一个特殊的文件，它并不是存储在磁盘上的文件。这个文件只有被读取的时候，才会由内核产生内容。因为这些内容是内核动态生成的，所以可以保证其中读到的地址是正确的，不会有System.map-&lt;kernel-version&gt;的问题。需要注意的是，从内核2.6.37开始，普通用户是没有办法从/proc/kallsyms中读到正确的值。在某些版本中，该文件为空。在较新的版本中，该文件中所有符号的地址均为0（除非/porc/sys/kernel/kptr_restrict 的值被设为0）。但是root用户是可以从/proc/kallsyms中读到正确的值的。好在加载模块也需要root权限，可以在加载模块时用脚本获取符号的地址。命令： #cat /proc/kallsyms | grep \"\\&lt;do_page_fault\\&gt;\" | awk '{print $1}' 不过，根据我的实际使用经验，/proc/kallsyms中符号的数量比Systemp.map-&lt;kernel-version&gt;要少一些。","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[],"author":"RichardUSTC"},{"title":"使用ioctl“实现”自定义的系统调用","slug":"2013-04-23-blog-4","date":"2013-04-23T00:04:00.000Z","updated":"2020-08-11T06:56:28.590Z","comments":true,"path":"2013-04-23-2013-04-23-blog-4.html","link":"","permalink":"http://richardustc.github.io/2013-04-23-2013-04-23-blog-4.html","excerpt":"","text":"最近做的项目跟Linux内核的关系比较大，我们的项目需要在用户态触发一些内核态的代码运行。众所周知，内核态的代码是不能直接被用户态代码调用的，用户态代码触发内核态代码的必须要经过系统调用。 为什么选择ioctl 那么该如何实现我们的需求呢？有几种方法： 改写内核，扩大系统调用表，添加新的系统调用 利用内核模块，覆盖没被使用或这使用频率很低的一个系统调用的处理函数 利用已有的系统调用，比如ioctl，来&ldquo;实现&rdquo;自定义的系统调用。 第一种方法需要修改内核，适用面比较窄；第二种方法hack意味很浓，没有被使用的系统调用号有限，不同模块可能都使用这种机制，可能会产生冲突。最终我们选择了第三种方法。下面将一一道来。 ioctl系统调用是用户态控制设备的接口，其用户态原型为 int ioctl(int d, int request, ...) 第一个参数是打开的设备文件的文件描述符，通常是open系统调用的返回值；第二个参数request是可以自定义的请求号；第三个参数可以是一个指针，指向一段用户态内存，用来传递参数，也可以是一个整形数据。函数原型中的'...'并非表示ioctl是可变参数函数，只是为了告诉编译器不要检查第三个参数。 在较新内核中，ioctl的内核态原型为unlock_ioctl long unlocked_ioctl(struct file *file, unsigned int request, unsigned long arg); 这个原型可以在struct file_operation的定义中找到，还有一个compat_ioctl，用于内核为64位，用户空间为32位的情形，跟我们的需求关系不大。 传入的request和arg就来自于ioctl系统调用的第二个和第三个参数。在内核态中，可以根据request的值，来调用约定的函数，&ldquo;实现&rdquo;自定义的系统调用。 需要注意的是，request的值并不是可以随随便便自定义的，需要遵循一些规则，可以参考《选择ioctl命令》（注意它用的ioctl的原型是老内核的）。 ioctl是用来操作设备的，因此我们需要一个虚拟的设备，以便ioctl能够工作。 如何实现 实现虚拟设备需要通过内核模块来实现。这篇文章写了如何写一个入门的内核模块。 在内核模块初始化代码中 用alloc_chrdev_region申请一个设备号 初始化一个struct file_operations类型的全局变量，将open、close、unlocked_ioctl等成员赋值为我们实现的函数。 利用cdev_add将设备号与file_operations关联起来 用class_create创建一个设备类 用device_create创建一个虚拟设备 在内核模块销毁代码中 用cdev_del解除设备号与设备操作之间的关联 用device_destroy销毁设备 用class_destroy销毁设备类 用unregister_chrdev_region释放设备号。 在自定义的unlocked_ioctl中 通过switch-case，根据request号进入某个case 如果目标函数没有参数，那么直接调用即可 如果要传递给目标函数的参数直接存储在arg中，则直接读取arg再调用即可。 如果要传递给目标函数的参数是arg所指向的一段用户态内存，则需要从用户态拷贝到内核态。较少的数据可以用get_user和put_user来读写，较多的数据可以用copy_from_user和copy_to_user来读写。准备好参数之后，调用目标函数。 编写字符设备驱动可以参考《Linux Device Driver》，网络上也有大量的教程，在此不再赘述。","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++类成员指针","slug":"2013-04-23-blog-5","date":"2013-04-22T20:04:00.000Z","updated":"2020-08-11T06:56:28.590Z","comments":true,"path":"2013-04-23-2013-04-23-blog-5.html","link":"","permalink":"http://richardustc.github.io/2013-04-23-2013-04-23-blog-5.html","excerpt":"","text":"类成员指针用法： 1 #include &lt;iostream&gt; 2 using namespace std; 3 4 class Test{ 5 public: 6 static int x; //static member 7 int y; 8 int foo(int i){ 9 return i; 10 } 11 int Test::* get_y_ptr(){ 12 return &amp;Test::y; 13 } 14 }; 15 int Test::x = 0; 16 17 int main(){ 18 cout&lt;&lt;hex&lt;&lt;&amp;(Test::x)&lt;&lt;endl; //we can get address of static member directly 19 Test t; 20 Test * pt = &amp;t; 21 t.y = 0xdeadbeef; 22 int Test::* p1 = &amp;Test::y; //get member pointer of x 23 cout&lt;&lt;hex&lt;&lt;t.*p1&lt;&lt;endl; 24 cout&lt;&lt;hex&lt;&lt;pt-&gt;*p1&lt;&lt;endl; 25 26 int Test::* p2 = t.get_y_ptr(); //get member pointer through function call 27 cout&lt;&lt;hex&lt;&lt;t.*p2&lt;&lt;endl; 28 cout&lt;&lt;hex&lt;&lt;pt-&gt;*p2&lt;&lt;endl; 29 30 int (Test::*func)(int) = &amp;Test::foo; //get member pointer of member function. pay attention to the position of '*' 31 cout&lt;&lt;(t.*func)(0)&lt;&lt;endl; // '()' around 't.*func' is essential 32 cout&lt;&lt;(pt-&gt;*func)(0)&lt;&lt;endl; // so is this case 33 return 0; 34 } 估计成员指针中存放的是该成员在对象中的相对偏移。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的枚举","slug":"2013-04-23-blog-6","date":"2013-04-22T17:04:00.000Z","updated":"2020-08-11T06:56:28.591Z","comments":true,"path":"2013-04-23-2013-04-23-blog-6.html","link":"","permalink":"http://richardustc.github.io/2013-04-23-2013-04-23-blog-6.html","excerpt":"","text":"没有类型名，全局作用域的枚举，比如enum {x0, x1, x2} 有类型名，全局作用域的枚举，比如enum var {y0, y1, y2}。前两种枚举中x0,x1,x2,y0,y1,y2的作用域是全局的，不能重复定义。比如第一种定义了x0，在enum var中就不能使用。 有类型名的，有作用域的枚举，比如enum class color{red, blue, yellow}或enum struct color{red, blue, yellow}这中enum是C++11的特性。这里面的red、blue和yellow是限定在color内部的，必须以color::red的形式来使用。 枚举值实际上是常量，可以在定义枚举的时候赋值，并且一个枚举之内的枚举值的值可以相同。比如 enum{x0=3, x1=5, x2=3}","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++特殊技巧","slug":"2013-04-22-blog-7","date":"2013-04-22T06:04:00.000Z","updated":"2020-08-11T06:56:28.589Z","comments":true,"path":"2013-04-22-2013-04-22-blog-7.html","link":"","permalink":"http://richardustc.github.io/2013-04-22-2013-04-22-blog-7.html","excerpt":"","text":"通过overloading new operation function和delete operator function来控制内存的分配。 placement new可以在指定内存处创建新对象，而并不申请新的内存。 可以在程序中直接调用析构函数，但是对应的内存并不会被释放。 可以通过typeid函数来取得类型信息（RTTI）","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++虚继承","slug":"2013-04-21-blog-8","date":"2013-04-21T00:04:00.000Z","updated":"2020-08-11T06:56:28.589Z","comments":true,"path":"2013-04-21-2013-04-21-blog-8.html","link":"","permalink":"http://richardustc.github.io/2013-04-21-2013-04-21-blog-8.html","excerpt":"","text":"C++中支持多重继承，但是菱形继承会带来一些问题。 比如D1和D2继承了B，而D又同时继承了D1和D2 1 class B{ 2 public: 3 int x; 4 }; 5 6 class D1:public B{ 7 }; 8 9 class D2:public B{ 10 }; 11 12 class D:public D1, public D2{ 13 }; 如果初始化一个D的对象，访问x就会产生歧义，因为D里面包含D1和D2的成员，而D1和D2各自有一份继承自B的x，编译器此时不知道该访问哪个x。 而虚继承能够保证菱形继承中，父类B的成员只出现一次，避免这种歧义。 1 class D1:virtual public B{ 2 }; 3 4 class D2:public virtual B{ 5 }; 注意：上面代码中第1行和第4行的两种写法都是可以的。 虚继承关键字写在D1和D2的继承列表上，但却对D1和D2没有影响，而是影响继承D1和D2的D。 但是虚继承也无法解决所有的歧义，比如： 1 class B{ 2 public: 3 int x; 4 }; 5 6 class D1:virtual public B{ 7 public: 8 int x; 9 }; 10 11 class D2:public virtual B{ 12 public: 13 int x; 14 }; 15 16 class D:public D1, public D2{ 17 }; 在这种情况下，即使使用了虚继承，创建D的对象访问x的时候仍然会发生歧义。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"小程序通用Makefile","slug":"2013-04-18-blog-10","date":"2013-04-18T01:04:00.000Z","updated":"2020-08-11T06:56:28.588Z","comments":true,"path":"2013-04-18-2013-04-18-blog-10.html","link":"","permalink":"http://richardustc.github.io/2013-04-18-2013-04-18-blog-10.html","excerpt":"","text":"有时候经常需要写一些小的测试用例，有一个Makefile会比较方便。于是就想到写一个比较通用的Makefile。 github地址：https://github.com/RichardUSTC/general-makefile 这个Makefile的特点： 支持C和C++程序 每个C/C++源文件编译成一个可执行程序 根据需要，可以通过make dump来dump出可执行程序的汇编代码，编译分析 make时可以在命令行指定CC、CXX、CFLAGS、CXXFLAGS、LDFLAGS、LIBS、OBJDUMP和DUMP_FLAGS变量。例如make LIBS=-lpthread。注意这时等号两侧不能有空格 编译出来的程序带有调试信息 使用时，放在源码所在目录即可 CC = gcc CXX = g++ OBJDUMP = objdump INCLUDES +=CFLAGS += -gCXXFLAGS += -gLDFLAGS +=LIBS +=DUMP_FLAGS = -d ifneq (${INCLUDES}, ) CFLAGS += -I${INCLUDES} CXXFLAGS += -I${INCLUDES}endif C_SRC = $(wildcard *.c)C_TARGET = $(patsubst %.c, %, ${C_SRC})C_DUMP= $(patsubst %.c, %.dump, ${C_SRC})CPP_SRC = $(wildcard *.cpp)CPP_TARGET = $(patsubst %.cpp, %, ${CPP_SRC})CPP_DUMP= $(patsubst %.cpp, %.dump, ${CPP_SRC})TARGET = ${C_TARGET} ${CPP_TARGET}DUMP = ${C_DUMP} ${CPP_DUMP} all: ${TARGET} dump: ${DUMP} ${TARGET} clean: @rm -f ${TARGET} ${DUMP} ${C_TARGET}: %: %.c ${CC} -o $@ $&lt; ${CFLAGS} ${LDFLAGS} ${LIBS} ${CPP_TARGET}: %: %.cpp ${CXX} -o $@ $&lt; ${CXXFLAGS} ${LDFLAGS} ${LIBS} ${DUMP}: %.dump: % ${OBJDUMP} ${DUMP_FLAGS} $&lt; &gt; $@ &nbsp; &nbsp;","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的异常处理","slug":"2013-04-18-blog-9","date":"2013-04-18T01:04:00.000Z","updated":"2020-08-11T06:56:28.588Z","comments":true,"path":"2013-04-18-2013-04-18-blog-9.html","link":"","permalink":"http://richardustc.github.io/2013-04-18-2013-04-18-blog-9.html","excerpt":"","text":"C++异常处理的语法 try{ ... throw aSomeException; ... }catch(SomeException e){ //code to handle the exception ... //optional rethrow throw; ... }或try{ ... //call a function that throws exception foo(); ...}catch(SomeException e){ //code to handle the exception ...} 异常的特性： 抛出异常如果没有被处理，就会往上一层抛出，直至被处理或者到达main函数。如果main函数中仍不能处理这个异常，那么就会调用terminate结束程序。 产生异常的时候，throw语句之后的代码不会被执行， 但是程序会自动析构局部对象。所以在可能发生异常的地方，应当把资源申请包装在类内部，在析构函数中自动释放。 析构函数中发生的异常需要在析构函数内部处理。否则，在异常向上抛出的过程中，析构函数再一次抛出异常会导致程序调用terminate，使得整个程序退出。 构造函数中如果发生异常，程序将自动释放已经初始化过的成员。 throw语句抛出的类型可以是基本类型，也可以是类类型。类类型需要有可访问的析构函数、move constructor(C++11中的特性)或者copy constructor。数组类型和函数将被转换为指针类型。抛出类型为编译时的静态类型，而不是动态运行时的类型。 throw语句抛出的类型如果是指针，需要保证指针指向的内容一直可用。 匹配catch块时使用第一次匹配到的catch块。 catch块中仍然可以throw，这次throw语句不带参数。如第一个例子中catch块中所示。 catch(...){}可以catch所有的异常。 构造函数中处理异常，示例 Foo::Foo(int i) try: foo_i(i) { //constructor body ... }catch(SomeException e){ //handle exception } 这种形式被成为function try block，这个异常处理函数既处理初始化列表中产生的异常，也处理constructor body中产生的异常。 &nbsp; &nbsp;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"页表自映射","slug":"2013-04-12-blog-11","date":"2013-04-11T20:04:00.000Z","updated":"2020-08-11T06:56:28.587Z","comments":true,"path":"2013-04-12-2013-04-12-blog-11.html","link":"","permalink":"http://richardustc.github.io/2013-04-12-2013-04-12-blog-11.html","excerpt":"","text":"今天查找页表映射资料时，无意发现一个有趣的概念，就是页表自映射。 页目录基址记为PDT，页目录项记为PDE，页表项记为PTE。BITS(m,n,value)表示取value从高m位到高n位的值。 这篇文章介绍了一个32位虚拟地址x的转换成物理地址过程。 32位系统下，所有的PTE所占的空间刚好是4MB。如果将这些PTE连续地放在内存中，那么这4MB内存空间对应的PTE（称为PTE的PTE）刚好在一个4KB页中，而这个4KB在页目录表中刚好也占一项。 如果再合理地设置4MB页表的地址，那么就可以使得PTE的PTE所占的4KB的内容与PDE所占的4KB的内容完全相同。这样一来，可以就可以将页目录表也作为一个页表，这也意味着，页目录表中有一项会指向自己。 页目录表本身占用4KB，所以它也刚好对应了一个PTE。而从前面的设置可以知道页目录表本身也是一个页表，那么指向页目录表的那个PTE必然也在页目录表当中。页目录表基址经过两级页表转换之后仍然可以转换成自己的物理地址，所以页目录表基地址的对应的PDE指向自己，对应的PTE也指向自己。 符合上面的要求的一个实例：将页表安排在0xc0000000~0xc0400000，页目录安排在0xc0300000~0xc0301000。 按照上面的设置，可以如下两个效果： 1. 通过一个页的PTE(xPTE)的虚地址v_pte，可以直接得到该页的虚地址为(v_pte&lt;&lt;10) 2. 通过一个页表的PDE(xPDE)的虚地址v_pde，可以直接得到该页表所在页的虚地址为( v_pde&lt;&lt;10) &nbsp; 下面来解释一下为什么： 1.1 首先看看v_pte自己转换成物理地址的过程 &nbsp; &nbsp; 1.1.1 v_pte取出BITS(31,22)在页目录表中查找，根据上面的设置，找到的PDE项刚好指向页目录表 &nbsp; &nbsp; 1.1.2 再取出BITS(21,12)，在页目录表（此时页目录表也作为一个页表）中查找，找到的PTE项指向xPTE所在的页表 &nbsp; &nbsp; 1.1.3 再计算页内偏移，找到了xPTE的物理地址 1.2 再来看看(v_pte&lt;&lt;10)转换成物理地址的过程 &nbsp; &nbsp; 1.2.1&nbsp;(v_pte&lt;&lt;10)取出BITS(31,22)（即v_pte的BITS(21,12)）在页目录表中查找，根据上面的巧妙设置，相当于1.1.2的过程，取到的PDE项指向xPTE所在的页表 &nbsp; &nbsp; 1.2.2 (v_pte&lt;&lt;10)取出BITS(21,12)（即v_pte的BITS（11, 2）在xPTE所在页表查找，找到的刚好是xPTE这个PTE &nbsp; &nbsp; 1.2.3 xPTE指向的页面的物理地址加上(v_pte&lt;&lt;10)的低12位（低12位为全0）就是(v_pte&lt;&lt;10)的物理地址。也就是说(v_pte&lt;&lt;10)对应的物理地址刚好就是xPTE指向的页面的物理地址，反过来，也就是说(v_pte&lt;&lt;10)就是这个页面的虚地址。 &nbsp; 2.1 首先看看xPDE自己的虚地址如何转换成物理地址 &nbsp; &nbsp; v_pde的BITS(31,12)刚好就等于页目录表基址，按照页目录表和页表位置的安排，有 &nbsp; &nbsp; 2.1.1 v_pde取出BITS(31,22)，找到的PDE指向页目录表本身 &nbsp; &nbsp; 2.1.2 v_pde取出BITS(21,12)，找到的PTE也指向页目录表本身 &nbsp; &nbsp; 2.1.3 v_pde取出BITS(11,0)作为偏移，加上页目录表的物理地址，得到v_pde的物理地址 2.2 再来看看(v_pde&lt;&lt;10)的虚地址如何转换成物理地址 &nbsp; &nbsp; 2.2.1&nbsp;(v_pde&lt;&lt;10)取出BITS(31,22)，也就是v_pde的BITS(21,12)，在页目录表中查找，找到的PDE指向页目录表本身，这一步相当于2.1.2 &nbsp; &nbsp; 2.2.2&nbsp;(v_pde&lt;&lt;10)取出BITS(21,12)，也就是v_pde的BITS(11, 2)，仍在页目录表中查找，找到的就是xPDE所指向的页表的物理地址 &nbsp; &nbsp; 2.2.3&nbsp;(v_pde&lt;&lt;10)的BITS(11,0)为全0，所以转换出来的物理地址等于xPDE所指向的页表的物理地址。(v_pde&lt;&lt;10)的物理地址等于xPDE所指向的页表的物理地址，反过来看，(v_pde&lt;&lt;10)就是xPDE所指向的页表的虚地址。 &nbsp; 参考资料： 潘爱民老师讲自映射页表的文章 linux的页表为什么没有实现自映射","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++格式化输出","slug":"2013-04-10-blog-12","date":"2013-04-10T06:04:00.000Z","updated":"2020-08-11T06:56:28.587Z","comments":true,"path":"2013-04-10-2013-04-10-blog-12.html","link":"","permalink":"http://richardustc.github.io/2013-04-10-2013-04-10-blog-12.html","excerpt":"","text":"这两篇文章对C++的格式化输出有比较好的介绍。 这篇的实例比较多，这一篇的列举比较详细。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"取得ld默认的ldscript配置","slug":"2013-04-09-blog-13","date":"2013-04-09T07:04:00.000Z","updated":"2020-08-11T06:56:28.585Z","comments":true,"path":"2013-04-09-2013-04-09-blog-13.html","link":"","permalink":"http://richardustc.github.io/2013-04-09-2013-04-09-blog-13.html","excerpt":"","text":"有时候我们需要修改一些链接时的参数，但是不想从零开始写一个链接脚本，这个时候可以利用命令 ld --verbose &gt; my_ldscript 通过这条命令得到的my_ldscript中有两行&ldquo;==========================&rdquo;分割线，取出两条分割线中间的内容就是ld默认使用的脚本了。 有了这个脚本，我们就可以根据自己的需要调整一下链接时的参数了。 比如，我在64位x86下，将这一行 PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS; 修改成 PROVIDE (__executable_start = SEGMENT_START(\"text-segment\",0x800000)); . = SEGMENT_START(\"text-segment\", 0x800000) + SIZEOF_HEADERS; 编译的时候使用-T指定链接脚本 gcc -c test.cgcc -o test -T my_ldscript test.o 编译出来的程序代码段就是从0x800000以上空间开始的了。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[],"author":"RichardUSTC"},{"title":"开始专注内核相关","slug":"2013-04-09-blog-14","date":"2013-04-09T06:04:00.000Z","updated":"2020-08-11T06:56:28.585Z","comments":true,"path":"2013-04-09-2013-04-09-blog-14.html","link":"","permalink":"http://richardustc.github.io/2013-04-09-2013-04-09-blog-14.html","excerpt":"","text":"最近的项目跟操作系统的内核关系不小，往后要看不少跟内核编程相关的资料了，有什么新的收获就会发在这里。","categories":[{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的类模版","slug":"2013-04-09-blog-16","date":"2013-04-09T06:04:00.000Z","updated":"2020-08-11T06:56:28.586Z","comments":true,"path":"2013-04-09-2013-04-09-blog-16.html","link":"","permalink":"http://richardustc.github.io/2013-04-09-2013-04-09-blog-16.html","excerpt":"","text":"C++中的类模版语法示例： templeate &lt;typename T&gt; class Foo{ ... }; 当然，typename也可以用class来替代。 如果类的成员函数单独拿出来写，语法示例： template &lt;typename T&gt; T Foo&lt;T&gt;::foo(T &amp;t){ return t; } 当然成员函数本身还可以再是模版函数 template &lt;typename T1&gt; class Foo{ ... template &lt;typename T2&gt; T2 foo(T2 &amp;t2); }; template &lt;typename T1&gt; template &lt;typename T2&gt;T2 Foo&lt;T1&gt;::foo(T2 &amp;t2){ return t2;} 类模版和函数模版一样，也可以指定nontype parameter。可以参考函数模版中的nontype parameter。 类模版参数和函数模版参数有时候会做一些非常小的转换，包括非const类型的转换成const类型、数组或函数转指针，以满足模版实例化的需求。 NOTE: 新学到一个知识点： class Foo{ ... typedef unsigned long size_t; ... }; 以后就可以使用Foo::size_t这个新定义的类型了。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++模版参考资料","slug":"2013-04-09-blog-15","date":"2013-04-09T06:04:00.000Z","updated":"2020-08-11T06:56:28.586Z","comments":true,"path":"2013-04-09-2013-04-09-blog-15.html","link":"","permalink":"http://richardustc.github.io/2013-04-09-2013-04-09-blog-15.html","excerpt":"","text":"来自www.cplusplus.com的关于C++模版的英文介绍资料，值得一读。 这篇资料里面涉及到函数模版和类模版，给出了很多实例。其中关于Template Specialization和Templates and multiple-file projects这两节需要特别注意。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中lambda的实现(2)","slug":"2013-03-31-blog-17","date":"2013-03-31T00:03:00.000Z","updated":"2020-08-11T06:56:28.584Z","comments":true,"path":"2013-03-31-2013-03-31-blog-17.html","link":"","permalink":"http://richardustc.github.io/2013-03-31-2013-03-31-blog-17.html","excerpt":"","text":"之前写了一篇C++中的lambda的实现(1)，从汇编语言的角度来分析了一下non-mutable lambda的实现方式。这篇文章主要介绍一下mutable lambda的实现方式。而这篇文章中有比较详细的lambda语法示例。 实验用gcc版本4.7.2，据说4.5以前的gcc不能支持C++11中的lambda。 C++源码 1 //lambda.cpp 2 #include &lt;iostream&gt; 3 using namespace std; 4 int main(){ 5 int a,b; 6 a = 1; 7 b = 2; 8 auto f = [&amp;a, &amp;b](int c)-&gt;int{ a++; b++; return a+b+c;}; //创建一个lambda表达式，'&amp;'表示a, b以引用传递， //可以被修改，并且修改会反映到main中的a、b 9 cout&lt;&lt;\"result= \"&lt;&lt;f(3)&lt;&lt;endl; 10 cout&lt;&lt;\"a= \"&lt;&lt;a&lt;&lt;endl; 11 cout&lt;&lt;\"b= \"&lt;&lt;b&lt;&lt;endl; 12 return 0; 13 } 编译运行 g++ -std=c++0x lambda.cpp -o lambda ./lambda result= 8 a= 2 b= 3 从结果来看，lamba表达式执行之后，a、b的值成功地被修改了。 下面这一段是main函数6-8行以及f(3)对应的汇编代码，同上次分析的一样，lambda在C++中编译成一个函数。 1 80487ea: c7 44 24 10 01 00 00 movl $0x1,0x10(%esp) # a=1 2 80487f1: 00 3 80487f2: c7 44 24 14 02 00 00 movl $0x2,0x14(%esp) # b=2 4 80487f9: 00 5 80487fa: 8d 44 24 10 lea 0x10(%esp),%eax 6 80487fe: 89 44 24 18 mov %eax,0x18(%esp) #0x18(%ebp)（记为ref_a)中存放了a的地址 7 8048802: 8d 44 24 14 lea 0x14(%esp),%eax 8 8048806: 89 44 24 1c mov %eax,0x1c(%esp) #0x1c(%ebp)（记为ref_b）中存放了b的地址 9 804880a: c7 44 24 04 03 00 00 movl $0x3,0x4(%esp) #将f(3)中的参数3放在栈上 10 8048811: 00 11 8048812: 8d 44 24 18 lea 0x18(%esp),%eax 12 8048816: 89 04 24 mov %eax,(%esp) #将ref_a的地址放在栈上 13 8048819: e8 8e ff ff ff call 80487ac &lt;_ZZ4mainENKUliE_clEi&gt; #调用lambda对应的函数 下面这一段是lambda函数所对应的汇编代码 80487ac: 55 push %ebp 80487ad: 89 e5 mov %esp,%ebp 80487af: 8b 45 08 mov 0x8(%ebp),%eax #取出上面一段汇编代码中12行所存的ref_a的地址 80487b2: 8b 00 mov (%eax),%eax #取出ref_a的值，也就是a的地址 80487b4: 8b 10 mov (%eax),%edx #取出a的值到edx 80487b6: 83 c2 01 add $0x1,%edx # a++ 80487b9: 89 10 mov %edx,(%eax) #存回a，注意这个时候是存回到了main函数栈上的a里面 80487bb: 8b 45 08 mov 0x8(%ebp),%eax #取出ref_a的地址 80487be: 8b 40 04 mov 0x4(%eax),%eax #ref_a和ref_b是紧挨着存储的 #这一条指令取出ref_b的值，也就是b的地址 80487c1: 8b 10 mov (%eax),%edx #取出b的值，放入edx 80487c3: 83 c2 01 add $0x1,%edx # b++ 80487c6: 89 10 mov %edx,(%eax) #存回b 80487c8: 8b 45 08 mov 0x8(%ebp),%eax 80487cb: 8b 00 mov (%eax),%eax 80487cd: 8b 10 mov (%eax),%edx #再取a的值，放在edx 80487cf: 8b 45 08 mov 0x8(%ebp),%eax 80487d2: 8b 40 04 mov 0x4(%eax),%eax 80487d5: 8b 00 mov (%eax),%eax 80487d7: 01 c2 add %eax,%edx #edx = a+b 80487d9: 8b 45 0c mov 0xc(%ebp),%eax #取出上一段汇编中第9行放在站上的参数3 80487dc: 01 d0 add %edx,%eax #eax= a+b+c，而函数返回值放在eax中 80487de: 5d pop %ebp 80487df: c3 ret 从上面的汇编分析来看，gcc在实现mutable lambda的时候，将lambda的代码编译为函数，将capture list中的可写变量的地址通过一些手段传入到lambda实现函数中。对比之下，non-mutable的lambda则将capture list中变量的值复制一遍，再将复制出来的变量的地址通过一些手段传入lambda实现函数。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的函数模版","slug":"2013-03-30-blog-18","date":"2013-03-30T06:03:00.000Z","updated":"2020-08-11T06:56:28.583Z","comments":true,"path":"2013-03-30-2013-03-30-blog-18.html","link":"","permalink":"http://richardustc.github.io/2013-03-30-2013-03-30-blog-18.html","excerpt":"","text":"函数模版 语法结构 template &lt;template_parameter_list&gt; [ inline | const_expr] func_name( func_parameter_list){ ... } template_parameter_list不能为空，多个template parameter之间用','来分隔。template parameter分为两种：type parameter和nontype parameter。 type paramter语法形式 typename | class type_name其中'typename'关键字和'class'关键字是等价的。推荐使用typename，因为模版适用的类型不仅仅是class，用typename表意更准确一些。 nontype parameter语法形式 type value_nametype在定义模版的时候必须指定，而value_name在模版体中作为一个常量来使用。在使用模版的时候，传进来的必须是常量表达式，比如常数、const指针或引用以及函数。 常见的函数模版示例 template&lt;typename T&gt; int compare(const T&amp; v1, const T&amp; v2){ if(less&lt;T&gt;()(v1, v2)) return 1; if(less&lt;T&gt;()(v2, v1)) return -1; return 0; } template&lt;int M, int N&gt; int compare(const char v1[M], const char v2[N]){ return strcmp(v1, v2); } NOTE: 定义模版的时候，应该尽可能少一些限定，以便适用面更广。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的虚函数(2)","slug":"2013-03-30-blog-19","date":"2013-03-30T05:03:00.000Z","updated":"2020-08-11T06:56:28.584Z","comments":true,"path":"2013-03-30-2013-03-30-blog-19.html","link":"","permalink":"http://richardustc.github.io/2013-03-30-2013-03-30-blog-19.html","excerpt":"","text":"C++中有一种特殊的虚函数&mdash;&mdash;纯虚函数。语法示例 class Foo{ ... virtual void foo()=0; ... }; 当一个类中包含纯虚函数的时候，就称该类为抽象类，不能生成该类的实例。如果子类继承了包含抽象父类，override了父类的所有的纯虚函数，那么就可以生成子类的实例了，否则子类也是抽象类。 &nbsp;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++ overload、override、overwrite","slug":"2013-03-29-blog-20","date":"2013-03-29T04:03:00.000Z","updated":"2020-08-11T06:56:28.581Z","comments":true,"path":"2013-03-29-2013-03-29-blog-20.html","link":"","permalink":"http://richardustc.github.io/2013-03-29-2013-03-29-blog-20.html","excerpt":"","text":"这篇文章对C++的overload、override和overwrite有一个详细的介绍。 Java与C++有些不同。 例如，父类实现了func()和func(int x)，子类继承父类之后只实现func()。C++中，子类的对象无法调用func(int x)，而Java中，子类的对象可以调用父类的func(int x)。 C++中也可以用using语句来实现类似Java的效果。 class Base{ void foo(){...} void foo(int){...} }; class Derived:public Base{ using Base::foo; void foo(){…}}; 在这种情况下，Derived类的对象就可以调用Base的foo(int)函数了。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++继承","slug":"2013-03-29-blog-21","date":"2013-03-29T02:03:00.000Z","updated":"2020-08-11T06:56:28.582Z","comments":true,"path":"2013-03-29-2013-03-29-blog-21.html","link":"","permalink":"http://richardustc.github.io/2013-03-29-2013-03-29-blog-21.html","excerpt":"","text":"1. C++继承语法 class Derived [: [private|protected|public] Base1, ...] 如果没有指定private、protected或public，则默认是private继承。如果是用struct来定义类，那么默认就是public继承。 使用这里的private、protected和public是用来控制Derived类的对象和子类对Base1等父类的成员的访问，而Derived类内部对与Base1等父类的成员的访问则只受父类的控制。 2. C++支持多重继承，但是这样容易出现菱形继承，容易产生歧义。关于菱形继承，这一有一篇文章可以参考。 3. C++中，子类的构造函数应该调用父类的构造函数来完成从父类继承的成员的初始化。语法 Derived(base_x, derived_y):Base(x), y(derived_y){ ... } 推荐使用父类的构造函数来初始化父类成员，即使有些情况下，父类的成员子类都可以访问，能在子类的构造函数函数体内部初始化。 4. C++中，推荐将父类和子类的析构函数设置为virtual函数，这样使用指针和引用的时候程序能够自动地找到正确的析构函数去执行。 5. 父类中定义了类静态变量，子类继承父类之后和父类使用同一个静态变量。 6. 只有使用public限定的继承才能实现子到父的类型转换。 7. 父类的友元不能直接访问子类的private成员，子类的友元也不能访问父类的private成员。 &nbsp;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的虚函数(1)","slug":"2013-03-29-blog-22","date":"2013-03-28T18:03:00.000Z","updated":"2020-08-11T06:56:28.582Z","comments":true,"path":"2013-03-29-2013-03-29-blog-22.html","link":"","permalink":"http://richardustc.github.io/2013-03-29-2013-03-29-blog-22.html","excerpt":"","text":"虚函数语法形式 class Foo{ ... virtual void func(); ... }; C++虚函数必须和C++的继承结合起来一起看。示例是最好的解释。 #include &lt;iostream&gt; using namespace std; class Base{ public: void func1(){ cout&lt;&lt;\"I'm Base func1\"&lt;&lt;endl; } virtual void func2(){ cout&lt;&lt;\"I'm Base func2\"&lt;&lt;endl; } }; class Derived:public Base{ public: void func1(){ cout&lt;&lt;“I’m Derived func1“&lt;&lt;endl; } virtual void func2(){ cout&lt;&lt;“I’m Derived func2“&lt;&lt;endl; }}; int main(){ Derived d= Derived(); Base &amp;o = d; //创建了一个指向子类对象的引用 o.func1(); //func1不是虚函数，因此使用了Base的func1方法 o.func2(); //func2是虚函数，因此根据引用所指向的实际对象的类型选择func2，即Derived的func2 return 0;} 运行结果 I'm Base func1 I'm Derived func2 汇编代码分析 40091c: 48 c7 45 f0 00 00 00 movq $0x0,-0x10(%rbp) #-0x10(%rbp)中存放的是对象d，这个对象占用8个字节 400923: 00 #这8个字节将会用来存储一个指针，指针指向Derived类的虚函数表 400924: 48 8d 45 f0 lea -0x10(%rbp),%rax 400928: 48 89 c7 mov %rax,%rdi 40092b: e8 18 01 00 00 callq 400a48 &lt;_ZN7DerivedC1Ev&gt; #调用Derived的默认构造函数 400930: 48 8d 45 f0 lea -0x10(%rbp),%rax 400934: 48 89 45 f8 mov %rax,-0x8(%rbp) #-0x8(%ebp)存储引用o，o的内容实际上是对象d的起始地址。 400938: 48 8b 45 f8 mov -0x8(%rbp),%rax 40093c: 48 89 c7 mov %rax,%rdi #这两行准备this指针 40093f: e8 70 00 00 00 callq 4009b4 &lt;_ZN4Base5func1Ev #不是虚函数，直接调用Base的func1 400944: 48 8b 45 f8 mov -0x8(%rbp),%rax #取出d的地址 400948: 48 8b 00 mov (%rax),%rax #取出d的内容，即指向Derived类虚函数表的指针 40094b: 48 8b 10 mov (%rax),%rdx #func2是Derived类的唯一虚函数，即第0项。取出func2的地址。 40094e: 48 8b 45 f8 mov -0x8(%rbp),%rax 400952: 48 89 c7 mov %rax,%rdi #这两行也是准备this指针 400955: ff d2 callq *%rdx #调用func2 如果感兴趣，可以用gdb实际调试一下，观察运行的过程。 NOTE 1:&nbsp;当子类不override父类的虚函数，那么子类就自动继承父类的虚函数。 NOTE 2: 虚函数也可以有默认参数。如果用父类的指针或引用指向子类的对象，那么调用的函数是子类的，使用的默认参数却是父类函数的。（C++真是无比混乱啊！） NOTE 3: 如果不想动态调用虚函数，可以使用类名+'::'来限定调用哪个函数。例如，上例中可以添加语句o.Base::func2()来调用父类的func2。 NOTE 4:父类的函数是虚函数，那么子类的对应的函数即使不添加virtual修饰，依然是虚函数。子类最好也添加上virtual修饰，这样代码含义更加清晰。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"gcc -save-temps选项","slug":"2013-03-21-blog-23","date":"2013-03-21T01:03:00.000Z","updated":"2020-08-11T06:56:28.581Z","comments":true,"path":"2013-03-21-2013-03-21-blog-23.html","link":"","permalink":"http://richardustc.github.io/2013-03-21-2013-03-21-blog-23.html","excerpt":"","text":"在很多开源项目中，作者喜欢用宏定义以及预处理中的拼接技术来生成一些函数。比如，在QEMU的源码中就使用这种方式来定义函数 // file1#define xglue(x, y) x ## y #define glue(x, y) xglue(x, y)// file2 #define HELPER(name) glue(helper_, name)// file3uint32_t HELPER(clz)(uint32_t x) { return clz32(x); } 其实最终的效果就是定义了 uint32_t helper_clz(uint32_t x) { return clz32(x); } 这种办法给项目的作者减少了一些重复书写的过程，但是却给阅读代码的人带来了很大的障碍。 为了解决这个问题，可以输出预处理之后的源码，方便阅读的过程中进行分析。gcc提供了一个选项-save-temps，可以保存编译过程中的中间文件，这里面就包括了预处理之后的源码。 在阅读QEMU代码的时候，可以在configure的过程中加入这个选项，比如 ./configure --target-list=arm-softmmu --extra-cflags=-save-temps 由于QEMU支持的平台很多，target-list指定多个目标可能会多次编译，后生成的中间文件可能会覆盖之前生成的，所以建议每次只添加一个目标。","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[],"author":"RichardUSTC"},{"title":"用Gmail备份多看的推送","slug":"2013-03-20-blog-24","date":"2013-03-20T07:03:00.000Z","updated":"2020-08-11T06:56:28.580Z","comments":true,"path":"2013-03-20-2013-03-20-blog-24.html","link":"","permalink":"http://richardustc.github.io/2013-03-20-2013-03-20-blog-24.html","excerpt":"","text":"前段时间好奇心起，研究了一下多看的推送系统。多看的推送其实使用邮箱来完成的。比如我在爱看豆网站上推送一本书到多看系统，爱看豆的后台会自动给在我在网站上设置的多看邮箱里发送一封邮件，并将这本书作为附件。kindle上的多看系统联网的时候，会自动检查我的多看邮箱中是否有邮件，如果有，则下载其附件，放在多看推送目录下。 前两天研究多看系统的时候在系统的log里面发现了多看推送系统的pop3登录用户名和密码，估计是程序员为了调试方便不小心输出的。 这两天无线路由器不在，没有办法用kindle接收多看的推送。于是我想起了用Gmail来接收多看邮箱的邮件。设置过程就不多说了，按照Google的提示来就行了。设置完成之后，果然在收件箱中看到了久违的电子书了，果断从邮箱中下载。以后只要多看不更改邮箱密码，那我就可以利用Gmail来备份推送到多看的电子书了。 &nbsp;","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[],"author":"RichardUSTC"},{"title":"拷贝构造函数与拷贝赋值","slug":"2013-03-19-blog-25","date":"2013-03-19T07:03:00.000Z","updated":"2020-08-11T06:56:28.580Z","comments":true,"path":"2013-03-19-2013-03-19-blog-25.html","link":"","permalink":"http://richardustc.github.io/2013-03-19-2013-03-19-blog-25.html","excerpt":"","text":"通常来说，需要实现析构函数的类都需要实现拷贝构造函数和拷贝赋值。如果没有实现自定义的拷贝构造用函数和拷贝赋值，那么编译器会自动实现它们。在编译器的实现里，如果成员是builtin类型，那么就直接赋值，如果是类类型的，那么就会调用类的相应函数来实现。特别要注意的是，如果是指针，那么只拷贝指针的值，即使是类指针类型也不例外。这就是所谓的浅拷贝。这里有一篇文章Shallow vs. deep copying介绍地更详细。 拷贝构造函数 拷贝构造函数的形式 class Foo{ Foo(); Foo(const Foo&amp;); }; &nbsp;拷贝构造函数的参数一般是const限定的引用，也可以使用非const限定的引用（后果如何我尚未弄明白）。 拷贝构造函数使用的场景 1. 声明的同时用另一个同类型对象定义。如：Foo a=Foo();这里的'='就使用拷贝构造函数。 2.以非引用的方式传递参数 3.以非引用的方式返回返回值 4.以花括号形式初始化对象数组或者给aggregate class的成员初始化。 禁止拷贝 如果设置拷贝构造函数为私有函数，那么外部类就无法实现此类对象的复制了。另外可以声明拷贝构造函数，但是不实现。那么试图拷贝该类的对象时，编译器会报错。 赋值拷贝 实现赋值拷贝就是实现参数形式为const限定的类引用的&lsquo;=&rsquo;的重载。 示例 class Foo{ Foo &amp; operator=(const Foo &amp;f); }; 示例中，返回值是左值的引用，如果设置返回值为void，那么就会阻止串联赋值（a=b=c）。一般应该返回左值的引用。 小结 不得不说，C++的语法细节太多，编译器常常在背后自动做了不少事情，很容易让程序员误入陷阱。相比之下，Java在语法这一块就简洁明晰很多了。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中lambda的实现(1)","slug":"2013-03-17-blog-26","date":"2013-03-17T02:03:00.000Z","updated":"2020-08-11T06:56:28.579Z","comments":true,"path":"2013-03-17-2013-03-17-blog-26.html","link":"","permalink":"http://richardustc.github.io/2013-03-17-2013-03-17-blog-26.html","excerpt":"","text":"在看C++ Primer的过程中，发现C++11标准中添加了lambda和类型推断系统。这篇文章介绍了很多lambda的实例。 为了弄清楚lambda的实现，特地做了一个小实验。这一次只看non-mutable lambda。测试的gcc版本为4.6.3（貌似4.5以前的gcc不支持lambda表达式）。 代码： 1 //test.cpp 2 #include &lt;iostream&gt; 3 template&lt;typename Func&gt; 4 void test(Func f){ 5 std::cout&lt;&lt;f(3)&lt;&lt;std::endl; 6 } 7 template&lt;typename Func&gt; 8 void test2(Func f){ 9 std::cout&lt;&lt;f(13)&lt;&lt;std::endl; 10 } 11 int main(){ 12 int a = 1; 13 int b = 2; 14 auto f = [a,b](int c){return a+b+c;}; 15 test(f); 16 a=2;b=3; 17 test2(f); 18 return 0; 19 } 编译方法 g++ -std=c++0x test.cpp -o test 运行结果 ./test 6 16 在这个例子中，代码第14行创建了一个non-mutable lambda。这里使用了类型自动推断，f的类型编译器会自动计算出来。[]称为capture list，里面的a和b的值同main里面的a和b的值是一样的，而且可以发现non-mutable lambda创建之后再对main中的a、b赋值，不会影响到capture list中的a和b的值。此外capture list中a和b是只读的，试图写这两个值时，编译器会报错。这个lamda函数的返回值类型是int，这也可以由编译器自动推断出来。 现在来看看生成的汇编代码，来看看C++是如何实现non-mutable lambda的。 下面这一段是从main函数的汇编代码中截取出来的，对应了C++代码第12行到15行。各行的意义参见注释。 1 8048612: c7 44 24 18 01 00 00 movl $0x1,0x18(%esp) #给main中的a赋值 2 8048619: 00 3 804861a: c7 44 24 1c 02 00 00 movl $0x2,0x1c(%esp) #给main中的b赋值 4 8048621: 00 5 8048622: 8b 44 24 18 mov 0x18(%esp),%eax 6 8048626: 89 44 24 10 mov %eax,0x10(%esp) #将main中的a值copy到capture list中的a（记为c_a) 7 804862a: 8b 44 24 1c mov 0x1c(%esp),%eax 8 804862e: 89 44 24 14 mov %eax,0x14(%esp) #将main中的b值copy到capture list中的b (记为c_b) 9 8048632: 8b 44 24 10 mov 0x10(%esp),%eax 10 8048636: 8b 54 24 14 mov 0x14(%esp),%edx 11 804863a: 89 04 24 mov %eax,(%esp) #%eax中放着c_a的值 12 804863d: 89 54 24 04 mov %edx,0x4(%esp) #将capture list中a、b的值分别取出，放在栈上作为函数调用的参数 #(分别记为c_a_copy1, c_b_copy1) 13 8048641: e8 2b 00 00 00 call 8048671 &lt;_Z4testIZ4mainEUliE_EvT_&gt; #调用test(f) 下面这一段是从函数模版test的汇编代码中截取的一段，对应了test中的f(3)这个表达式。 1 8048677: c7 44 24 04 03 00 00 movl $0x3,0x4(%esp) #将3作为参数放在栈上 2 804867e: 00 3 804867f: 8d 45 08 lea 0x8(%ebp),%eax #0x8(%ebp)对应的地址就是c_a_copy1 4 8048682: 89 04 24 mov %eax,(%esp) #将这个地址(c_a_copy1的地址）放在栈上 5 8048685: e8 6a ff ff ff call 80485f4 &lt;_ZZ4mainENKUliE_clEi&gt; #调用lambda的代码 下面是lambda代码对应的汇编码 1 80485f7: 8b 45 08 mov 0x8(%ebp),%eax #将c_a_copy1的地址取出 2 80485fa: 8b 10 mov (%eax),%edx #%edx中存放c_a_copy1的值 3 80485fc: 8b 45 08 mov 0x8(%ebp),%eax 4 80485ff: 8b 40 04 mov 0x4(%eax),%eax #%eax中存放着c_b_copy1的值 5 8048602: 01 d0 add %edx,%eax 6 8048604: 03 45 0c add 0xc(%ebp),%eax #0xc(%ebp)中放着参数c的值，着两行对应a+b+c 从上面的代码来看，C++在编译lambda的时将lambda作为一个特殊的函数来处理。non-mutable lambda编译出来的代码与函数的代码类似，capture list中的值是存放在创建者（本例中是main函数）的栈上的。使用non-mutable lambda的时候，capture list中的值被拷贝出来放在调用栈上，在lambda函数中取出来使用。 下面再来看一下main中的另一段汇编代码，这一段代码对应着C++中的16和17行。 1 8048646: c7 44 24 18 02 00 00 movl $0x2,0x18(%esp) #给a赋值为2，没有影响c_a的值 2 804864d: 00 3 804864e: c7 44 24 1c 03 00 00 movl $0x3,0x1c(%esp) #给b赋值为3，没有影响到c_b的值 4 8048655: 00 5 8048656: 8b 44 24 10 mov 0x10(%esp),%eax 6 804865a: 8b 54 24 14 mov 0x14(%esp),%edx 7 804865e: 89 04 24 mov %eax,(%esp) 8 8048661: 89 54 24 04 mov %edx,0x4(%esp) #仍然是从c_a和c_b中拷贝值放在栈上 9 8048665: e8 42 00 00 00 call 80486ac &lt;_Z5test2IZ4mainEUliE_EvT_&gt; #调用test2(f)，后面部分的原理与test(f)相似 从这段代码我们可以看出，capture list中的变量的值使用的是non-mutable lambda创建的时刻的值，以后不随着capture list外的值的变化而变化。 这篇文章分析了一下mutable lambda的实现。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的算法","slug":"2013-03-17-blog-27","date":"2013-03-16T23:03:00.000Z","updated":"2020-08-11T06:56:28.579Z","comments":true,"path":"2013-03-17-2013-03-17-blog-27.html","link":"","permalink":"http://richardustc.github.io/2013-03-17-2013-03-17-blog-27.html","excerpt":"","text":"C++中将算法和容器进行了很好的分离。容器用来存储数据，仅仅提供一些基本的操作，而算法则做到跟底层的数据结构无关。联系容器和算法的关键是迭代器。 算法不会更改容器的大小，但是也有一些特殊情况，执行过算法之后容器的大小改变了。但是要注意的是，改变容器大小的不是算法，而是迭代器。比如，这里有一个back_inserter的例子。unique算法是去掉容器中重复的元素，执行unique完算法之后，会返回一个新的指向容器末尾的迭代器，程序员需要自己手动删除新尾到原尾之间的元素。 使用算法的时候需要注意的是算法一般不会对容器的大小、迭代器是否有效进行检查，这些都需要程序员在调用算法之前自己检查。 C++标准库中的算法主要集中在&lt;algorithm&gt;和&lt;numeric&gt;中。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"QEMU编译及使用方法","slug":"2013-03-15-blog-28","date":"2013-03-14T21:03:00.000Z","updated":"2020-08-11T06:56:28.578Z","comments":true,"path":"2013-03-15-2013-03-15-blog-28.html","link":"","permalink":"http://richardustc.github.io/2013-03-15-2013-03-15-blog-28.html","excerpt":"","text":"QEMU是一个支持跨平台虚拟化的虚拟机，有user mode和system mode两种配置方式。其中qemu在system mode配置下模拟出整个计算机，可以在qemu之上运行一个操作系统。QEMU的system mode与常见的VMware和Virtualbox等虚拟机比较相似，但是QEMU的优势是可以跨指令集。例如，VMware和Virtualbox之类的工具通常只能在x86计算机上虚拟出一个x86计算机，而QEMU支持在x86上虚拟出一个ARM计算机。qemu在user mode配置下，可以运行跟当前平台指令集不同的平台可执行程序。例如可以用qemu在x86上运行ARM的可执行程序，但是两个平台必须是同一种操作系统，比如Linux。 QEMU还支持很多其他的平台，详细列表参见这里。 QEMU中有两个重要的名词host和target(guest)，其中host表示qemu程序本身运行的平台，target(guest)表示qemu虚拟出的计算机平台(system mode)或支持的可执行程序的运行平台(user mode)。 下面描述一下编译和使用host为x86，target(guest)为ARM的步骤 1. 下载QEMU源码 wget http://wiki.qemu-project.org/download/qemu-1.4.0.tar.bz2 2. 解压、configure tar xvf qemu-1.4.0.tar.bz2 cd qemu-1.4.0 ./configure --target-list=arm-softmmu,arm-linux-user --prefix=&lt;prefix&gt; 其中--target-list指定需要编译的target(guest)，arm-softmmu表示要编译system mode的QEMU，arm-linux-user表示要编译user mode的QEMU。 如果configure提示缺少某些库的话，按照提示安装即可。 3. make和安装 make &amp;&amp; make install 编译完成之后，得到的qemu-system-arm对应的就是system mode的虚拟机，qemu-arm对应的就是user mode的模拟器。 4. 使用qemu-arm 使用qemu-arm的方法很简单，只需要在原来的程序执行命令之前添加qemu-arm即可。 例如： 原来运行命令 &lt;executable&gt; &lt;arg1&gt; &lt;arg2&gt;&nbsp;... &nbsp;&nbsp;使用qemu-arm运行 qemu-arm &lt;executable&gt; &lt;arg1&gt; &lt;arg2&gt; ... 5. 使用qemu-system-arm 使用qemu-system-arm的方法相对稍微复杂。 这里有一个qemu-system-arm安装使用debian教程，教程中用到的版本比较老，可以在这里下载较新的版本，安装原理是类似的。","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的顺序容器","slug":"2013-03-14-blog-29","date":"2013-03-14T05:03:00.000Z","updated":"2020-08-11T06:56:28.577Z","comments":true,"path":"2013-03-14-2013-03-14-blog-29.html","link":"","permalink":"http://richardustc.github.io/2013-03-14-2013-03-14-blog-29.html","excerpt":"","text":"继续之前的C++复习笔记。 顺序容器中放置的元素不能是引用或者不可复制的对象（比如输入输出流对象）。 C++中的顺序容器有vector、deque、forward_list。 在复习这一部分的时候，遇到了C++中的adaptor的概念。adaptor在用已有的类（函数、迭代器）为基础，创造出另一种不同功能的类（函数、迭代器）。 例如 stack&lt;int, vector&lt;int&gt; &gt; s; 里面的stack类使用vector作为基础数据结构，利用vector的成员函数包装出back(), push_back()和pop()，实现栈功能。 C++中的顺序容器： 1. vector 2. deque 3. forward_list 4. stack 5. queue 6. priority_queue 7. ...","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"--build、--host和--target选项","slug":"2013-03-13-blog-30","date":"2013-03-13T05:03:00.000Z","updated":"2020-08-11T06:56:28.576Z","comments":true,"path":"2013-03-13-2013-03-13-blog-30.html","link":"","permalink":"http://richardustc.github.io/2013-03-13-2013-03-13-blog-30.html","excerpt":"","text":"在交叉编译configure时，通常会需要设置--build、--host和--target选项。各个选项的含义如下： --build：编译所用的机器的平台。 --host：编译出的代码运行的平台。 --target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。 在不涉及到交叉编译的时候，--build、--host、--target是一样的，不需要特别设置。交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置--build和--host选项。 通常，本机上的gcc、ld等工具是没有前缀的，这个时候--build可以设置为空。交叉编译工具链通常都有一个前缀，比如arm-unknown-linux-gnueabi-gcc，这个时候，--host就要设置为arm-unknown-linux-gnueabi。 Example: ./configure --build='' --host=arm-unknown-gnueabi 这篇文章Configure with --host, --target and --build options有更多的示例","categories":[{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中命名强制类型转换","slug":"2013-01-28-blog-31","date":"2013-01-28T06:01:00.000Z","updated":"2020-08-11T06:56:28.565Z","comments":true,"path":"2013-01-28-2013-01-28-blog-31.html","link":"","permalink":"http://richardustc.github.io/2013-01-28-2013-01-28-blog-31.html","excerpt":"","text":"在C++中有四种命名强制类型转换：const_cast、static_cast、dynamic_cast和reinterpret_cast。这篇文章对C++中的强制类型转换讲得比较清楚。 1. const_cast &nbsp; &nbsp; const_cast用于将const类型转换为非const类型，例如： const char *str = \"hello\"; char *p = const_cast&lt;char *&gt;(str); 2. static_cast和dynamic_cast &nbsp; &nbsp; 这两种cast功能相似，但是static_cast没有动态检查的功能，而dynamic_cast有动态检查的功能。 3. reinterprete_cast &nbsp; &nbsp; 例子： int a; char *c = reinterpret_cast&lt;char *&gt;(a); 4. 一个小例子的分析 class A{ int a; public: A(){ a = 0; } }; class AA:public A{ int aa; public: AA(){ aa = 0; } virtual int get_aa(){ //如果没有这个虚函数，那么下面的dynamic_cast无法编译通过 return aa; } }; class B{ int b; public: B(){ b = 0; } }; int main(){ A *x; AA *y; B *z; static_cast&lt;A *&gt;(y); //向上转换 //static_cast&lt;B *&gt;(y); //无法编译通过 dynamic_cast&lt;B *&gt;(y); //运行时转换的结果是NULL reinterpret_cast&lt;B *&gt;(x); //reinterpret_cast比较粗暴 return 0; } &nbsp;设计得当的话，强制类型转换是可以避免的。应当尽量不要使用强制类型转换。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"新分类：C++复习笔记","slug":"2013-01-28-blog-33","date":"2013-01-28T05:01:00.000Z","updated":"2020-08-11T06:56:28.574Z","comments":true,"path":"2013-01-28-2013-01-28-blog-33.html","link":"","permalink":"http://richardustc.github.io/2013-01-28-2013-01-28-blog-33.html","excerpt":"","text":"&nbsp; &nbsp; 很久以前，在大一的时候自学过一段时间的C++，当时学得不算精熟，后来又很长时间没有正经地使用C++。正好今年要找工作了，估计面试用得着，因此接着这次机会好好复习一下C++。 &nbsp; &nbsp; 现在看的书是《C++ Primer》，这本书的口碑不错。后面的C++复习笔记应该主要就是基于这本书了。 &nbsp; &nbsp; 这次C++复习的重点在以下几个方面： 搜集C++中一些小的但是容易忽略的知识点 异常处理 容器 算法 模版和泛型编程 命名空间 &nbsp; &nbsp; C++语言的基本内容复习完之后，应该就要开始了解一些常用的开发模式了。 &nbsp; &nbsp; 努力坚持下去！","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"C++中的new和delete","slug":"2013-01-28-blog-32","date":"2013-01-28T05:01:00.000Z","updated":"2020-08-11T06:56:28.566Z","comments":true,"path":"2013-01-28-2013-01-28-blog-32.html","link":"","permalink":"http://richardustc.github.io/2013-01-28-2013-01-28-blog-32.html","excerpt":"","text":"1. new用于动态创建对象。一般用法: int *i = new int(128); ClassX * c = new ClassX; 如果new的时候没有指定初始化参数，那么会调用默认构造函数来完成对象初始化。 2. new也可以用于创建动态数组。 一般用法： ClassX [] array = new ClassX[10]; 3. new可以用于创建动态的const对象： const ClassX * p = new const ClassX; 4. delete用于释放new创建的对象。一般用法： delete i; delete c; 5. 释放动态数组的时候，delete用法： delete [] array; 6. 释放const对象。与一般释放方法没有区别: delete p; &nbsp;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"}],"tags":[],"author":"RichardUSTC"},{"title":"第一篇博客","slug":"2013-01-28-blog-34","date":"2013-01-27T22:01:00.000Z","updated":"2020-08-11T06:56:28.576Z","comments":true,"path":"2013-01-28-2013-01-28-blog-34.html","link":"","permalink":"http://richardustc.github.io/2013-01-28-2013-01-28-blog-34.html","excerpt":"","text":"这是我在博客园的第一篇博客，希望以后能够坚持下去，在写博客的过程中提高自己！","categories":[{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"}],"tags":[],"author":"RichardUSTC"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/categories/Python/"},{"name":"PyQt","slug":"PyQt","permalink":"http://richardustc.github.io/categories/PyQt/"},{"name":"C#","slug":"C","permalink":"http://richardustc.github.io/categories/C/"},{"name":"Toolchain","slug":"Toolchain","permalink":"http://richardustc.github.io/categories/Toolchain/"},{"name":"CPP","slug":"CPP","permalink":"http://richardustc.github.io/categories/CPP/"},{"name":"LLVM","slug":"LLVM","permalink":"http://richardustc.github.io/categories/LLVM/"},{"name":"Other","slug":"Other","permalink":"http://richardustc.github.io/categories/Other/"},{"name":"Javascript","slug":"Javascript","permalink":"http://richardustc.github.io/categories/Javascript/"},{"name":"Command-Line","slug":"Command-Line","permalink":"http://richardustc.github.io/categories/Command-Line/"},{"name":"Regex","slug":"Regex","permalink":"http://richardustc.github.io/categories/Regex/"},{"name":"Kernel","slug":"Kernel","permalink":"http://richardustc.github.io/categories/Kernel/"},{"name":"Git","slug":"Git","permalink":"http://richardustc.github.io/categories/Git/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://richardustc.github.io/tags/Python/"},{"name":"PyQt","slug":"PyQt","permalink":"http://richardustc.github.io/tags/PyQt/"}]}