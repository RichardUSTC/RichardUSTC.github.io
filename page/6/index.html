<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Richard Lee&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Personal Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Richard Lee&#39;s Blog">
<meta property="og:url" content="http://richardustc.github.io/page/6/index.html">
<meta property="og:site_name" content="Richard Lee&#39;s Blog">
<meta property="og:description" content="Personal Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Richard Lee">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Richard Lee&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.0.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Richard Lee&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://richardustc.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2013-03-29-blog-21" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-29-2013-03-29-blog-21.html" class="article-date">
  <time datetime="2013-03-29T02:03:00.000Z" itemprop="datePublished">2013-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-29-2013-03-29-blog-21.html">C++继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1. C++继承语法</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span> Derived [: [<span style="color: #0000ff;">private</span>|<span style="color: #0000ff;">protected</span>|<span style="color: #0000ff;">public</span>] Base1, ...]</pre>
</div>
<p>如果没有指定private、protected或public，则默认是private继承。如果是用struct来定义类，那么默认就是public继承。</p>
<p>使用这里的private、protected和public是用来控制Derived类的对象和子类对Base1等父类的成员的访问，而Derived类内部对与Base1等父类的成员的访问则只受父类的控制。</p>
<p>2. C++支持多重继承，但是这样容易出现菱形继承，容易产生歧义。<a title="菱形继承" href="http://blog.csdn.net/icerlion/article/details/4409618" target="_blank">关于菱形继承，这一有一篇文章可以参考</a>。</p>
<p>3. C++中，子类的构造函数应该调用父类的构造函数来完成从父类继承的成员的初始化。语法</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Derived(base_x, derived_y):Base(x), y(derived_y){
    ...
}</span></pre>
</div>
<p>推荐使用父类的构造函数来初始化父类成员，即使有些情况下，父类的成员子类都可以访问，能在子类的构造函数函数体内部初始化。</p>
<p>4. C++中，推荐将父类和子类的析构函数设置为virtual函数，这样使用指针和引用的时候程序能够自动地找到正确的析构函数去执行。</p>
<p>5. 父类中定义了类静态变量，子类继承父类之后和父类使用同一个静态变量。</p>
<p>6. 只有使用public限定的继承才能实现子到父的类型转换。</p>
<p>7. 父类的友元不能直接访问子类的private成员，子类的友元也不能访问父类的private成员。</p>
<p>&nbsp;</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-29-2013-03-29-blog-21.html" data-id="ckdpm8hq3000hqpdah4xae6id" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-29-blog-22" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-29-2013-03-29-blog-22.html" class="article-date">
  <time datetime="2013-03-28T18:03:00.000Z" itemprop="datePublished">2013-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-29-2013-03-29-blog-22.html">C++中的虚函数(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>虚函数语法形式</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo{
    ...
    </span><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func();
    ...
};</span></pre>
</div>
<p>C++虚函数必须和C++的继承结合起来一起看。示例是最好的解释。</p>
<div class="cnblogs_code">
<pre>#include &lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Base{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> func1(){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">I'm Base func1</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
        }
        </span><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func2(){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">I'm Base func2</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
        }
};

<p></span><span style="color: #0000ff;">class</span> Derived:<span style="color: #0000ff;">public</span><span style="color: #000000;"> Base{<br>    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br>        </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> func1(){<br>            cout</span>&lt;&lt;<span style="color: #800000;">“</span><span style="color: #800000;">I’m Derived func1</span><span style="color: #800000;">“</span>&lt;&lt;<span style="color: #000000;">endl;<br>        }<br>        </span><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func2(){<br>            cout</span>&lt;&lt;<span style="color: #800000;">“</span><span style="color: #800000;">I’m Derived func2</span><span style="color: #800000;">“</span>&lt;&lt;<span style="color: #000000;">endl;<br>        }<br>};</p>
<p></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    Derived d</span>=<span style="color: #000000;"> Derived();<br>    Base </span>&amp;o =<span style="color: #000000;"> d;            //创建了一个指向子类对象的引用<br>    o.func1();              //func1不是虚函数，因此使用了Base的func1方法<br>    o.func2();              //func2是虚函数，因此根据引用所指向的实际对象的类型选择func2，即Derived的func2<br>    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></pre></p>
</div>
<p>运行结果</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">I'm Base func1
I'm Derived func2</span></pre>
</div>
<p>汇编代码分析</p>
<div class="cnblogs_code">
<pre>  4<span style="color: #800080;">0091c</span>:       <span style="color: #800080;">48</span> c7 <span style="color: #800080;">45</span> f0 <span style="color: #800080;">00</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movq   $0x0,-0x10(%rbp)          #-0x10(%rbp)中存放的是对象d，这个对象占用8个字节
  </span><span style="color: #800080;">400923</span>:       <span style="color: #800080;">00</span>                                                       #这8个字节将会用来存储一个指针，指针指向Derived类的虚函数表
  <span style="color: #800080;">400924</span>:       <span style="color: #800080;">48</span> 8d <span style="color: #800080;">45</span> f0             <span style="color: #0000ff;">lea</span><span style="color: #000000;">    -0x10(%rbp),%rax
  </span><span style="color: #800080;">400928</span>:       <span style="color: #800080;">48</span> <span style="color: #800080;">89</span> c7                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %rax,%rdi
  4</span><span style="color: #800080;">0092b</span>:       e8 <span style="color: #800080;">18</span> <span style="color: #800080;">01</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span>          callq  4<span style="color: #800080;">00a48</span><span style="color: #000000;"> &lt;_ZN7DerivedC1Ev&gt;  #调用Derived的默认构造函数
  </span><span style="color: #800080;">400930</span>:       <span style="color: #800080;">48</span> 8d <span style="color: #800080;">45</span> f0             <span style="color: #0000ff;">lea</span><span style="color: #000000;">    -0x10(%rbp),%rax
  </span><span style="color: #800080;">400934</span>:       <span style="color: #800080;">48</span> <span style="color: #800080;">89</span> <span style="color: #800080;">45</span> f8             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %rax,-0x8(%rbp)           #-0x8(%ebp)存储引用o，o的内容实际上是对象d的起始地址。
  </span><span style="color: #800080;">400938</span>:       <span style="color: #800080;">48</span> 8b <span style="color: #800080;">45</span> f8             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    -0x8(%rbp),%rax
  4</span><span style="color: #800080;">0093c</span>:       <span style="color: #800080;">48</span> <span style="color: #800080;">89</span> c7                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %rax,%rdi                 #这两行准备this指针
  4</span><span style="color: #800080;">0093f</span>:       e8 <span style="color: #800080;">70</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span>          callq  4<span style="color: #800080;">009b4</span><span style="color: #000000;"> &lt;_ZN4Base5func1Ev  #不是虚函数，直接调用Base的func1
  </span><span style="color: #800080;">400944</span>:       <span style="color: #800080;">48</span> 8b <span style="color: #800080;">45</span> f8             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    -0x8(%rbp),%rax           #取出d的地址
  </span><span style="color: #800080;">400948</span>:       <span style="color: #800080;">48</span> 8b <span style="color: #800080;">00</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    (%rax),%rax               #取出d的内容，即指向Derived类虚函数表的指针
  4</span><span style="color: #800080;">0094b</span>:       <span style="color: #800080;">48</span> 8b <span style="color: #800080;">10</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    (%rax),%rdx               #func2是Derived类的唯一虚函数，即第0项。取出func2的地址。
  4</span><span style="color: #800080;">0094e</span>:       <span style="color: #800080;">48</span> 8b <span style="color: #800080;">45</span> f8             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    -0x8(%rbp),%rax
  </span><span style="color: #800080;">400952</span>:       <span style="color: #800080;">48</span> <span style="color: #800080;">89</span> c7                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %rax,%rdi                 #这两行也是准备this指针
  </span><span style="color: #800080;">400955</span>:       ff d2                   callq  *%rdx                     #调用func2</pre>
</div>
<p>如果感兴趣，可以用gdb实际调试一下，观察运行的过程。</p>
<p><strong>NOTE 1:&nbsp;</strong>当子类不override父类的虚函数，那么子类就自动继承父类的虚函数。</p>
<p><strong>NOTE 2: </strong>虚函数也可以有默认参数。如果用父类的指针或引用指向子类的对象，那么调用的函数是子类的，使用的默认参数却是父类函数的。（C++真是无比混乱啊！）</p>
<p><strong>NOTE 3:</strong> 如果不想动态调用虚函数，可以使用类名+'::'来限定调用哪个函数。例如，上例中可以添加语句o.Base::func2()来调用父类的func2。</p>
<p><strong>NOTE 4:</strong>父类的函数是虚函数，那么子类的对应的函数即使不添加virtual修饰，依然是虚函数。子类最好也添加上virtual修饰，这样代码含义更加清晰。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-29-2013-03-29-blog-22.html" data-id="ckdpm8hq7000rqpdaaqzm5zau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-21-blog-23" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-21-2013-03-21-blog-23.html" class="article-date">
  <time datetime="2013-03-21T01:03:00.000Z" itemprop="datePublished">2013-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Toolchain/">Toolchain</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-21-2013-03-21-blog-23.html">gcc -save-temps选项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在很多开源项目中，作者喜欢用宏定义以及预处理中的拼接技术来生成一些函数。比如，在QEMU的源码中就使用这种方式来定义函数</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">//  file1<br />#define</span> xglue(x, y) x ## y
<span style="color: #0000ff;">#define</span> glue(x, y) xglue(x, y)<br />//  file2
<span style="color: #0000ff;">#define</span> HELPER(name) glue(helper_, name)<br />//  file3<br /><span style="color: #000000;">uint32_t HELPER(clz)(uint32_t x)
{
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> clz32(x);
}</span></pre>
</div>
<p>其实最终的效果就是定义了</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">uint32_t helper_clz(uint32_t x)
{
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> clz32(x);
}</span></pre>
</div>
<p>这种办法给项目的作者减少了一些重复书写的过程，但是却给阅读代码的人带来了很大的障碍。</p>
<p>为了解决这个问题，可以输出预处理之后的源码，方便阅读的过程中进行分析。gcc提供了一个选项-save-temps，可以保存编译过程中的中间文件，这里面就包括了预处理之后的源码。</p>
<p>在阅读QEMU代码的时候，可以在configure的过程中加入这个选项，比如</p>
<div class="cnblogs_code">
<pre>./configure --target-list=arm-softmmu --extra-cflags=-save-temps</pre>
</div>
<p>由于QEMU支持的平台很多，target-list指定多个目标可能会多次编译，后生成的中间文件可能会覆盖之前生成的，所以建议每次只添加一个目标。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-21-2013-03-21-blog-23.html" data-id="ckdpm8hq4000kqpda990s1cy2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-20-blog-24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-20-2013-03-20-blog-24.html" class="article-date">
  <time datetime="2013-03-20T07:03:00.000Z" itemprop="datePublished">2013-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Other/">Other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-20-2013-03-20-blog-24.html">用Gmail备份多看的推送</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间好奇心起，研究了一下多看的推送系统。多看的推送其实使用邮箱来完成的。比如我在爱看豆网站上推送一本书到多看系统，爱看豆的后台会自动给在我在网站上设置的多看邮箱里发送一封邮件，并将这本书作为附件。kindle上的多看系统联网的时候，会自动检查我的多看邮箱中是否有邮件，如果有，则下载其附件，放在多看推送目录下。</p>
<p>前两天研究多看系统的时候在系统的log里面发现了多看推送系统的pop3登录用户名和密码，估计是程序员为了调试方便不小心输出的。</p>
<p>这两天无线路由器不在，没有办法用kindle接收多看的推送。于是我想起了用Gmail来接收多看邮箱的邮件。设置过程就不多说了，按照Google的提示来就行了。设置完成之后，果然在收件箱中看到了久违的电子书了，果断从邮箱中下载。以后只要多看不更改邮箱密码，那我就可以利用Gmail来备份推送到多看的电子书了。</p>
<p>&nbsp;</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-20-2013-03-20-blog-24.html" data-id="ckdpm8hq3000gqpdahw4lguap" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-19-blog-25" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-19-2013-03-19-blog-25.html" class="article-date">
  <time datetime="2013-03-19T07:03:00.000Z" itemprop="datePublished">2013-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-19-2013-03-19-blog-25.html">拷贝构造函数与拷贝赋值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常来说，需要实现析构函数的类都需要实现拷贝构造函数和拷贝赋值。如果没有实现自定义的拷贝构造用函数和拷贝赋值，那么编译器会自动实现它们。在编译器的实现里，如果成员是builtin类型，那么就直接赋值，如果是类类型的，那么就会调用类的相应函数来实现。特别要注意的是，如果是指针，那么只拷贝指针的值，即使是类指针类型也不例外。这就是所谓的浅拷贝。这里有一篇文章<a href="http://www.learncpp.com/cpp-tutorial/912-shallow-vs-deep-copying/" target="_blank">Shallow vs. deep copying</a>介绍地更详细。</p>
<h1>拷贝构造函数</h1>
<h2>拷贝构造函数的形式</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo{<br />    Foo();
    Foo(</span><span style="color: #0000ff;">const</span> Foo&amp;<span style="color: #000000;">);
};</span></pre>
</div>
<p>&nbsp;拷贝构造函数的参数一般是const限定的引用，也可以使用非const限定的引用（后果如何我尚未弄明白）。</p>
<h2>拷贝构造函数使用的场景</h2>
<p>1. 声明的同时用另一个同类型对象定义。如：Foo a=Foo();这里的'='就使用拷贝构造函数。</p>
<p>2.以非引用的方式传递参数</p>
<p>3.以非引用的方式返回返回值</p>
<p>4.以花括号形式初始化对象数组或者给<a href="http://en.wikipedia.org/wiki/C%2B%2B_classes#Aggregate_classes" target="_blank">aggregate class</a>的成员初始化。</p>
<h2>禁止拷贝</h2>
<p>如果设置拷贝构造函数为私有函数，那么外部类就无法实现此类对象的复制了。另外可以声明拷贝构造函数，但是不实现。那么试图拷贝该类的对象时，编译器会报错。</p>
<h1>赋值拷贝</h1>
<p>实现赋值拷贝就是实现参数形式为const限定的类引用的&lsquo;=&rsquo;的重载。</p>
<p>示例</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo{
    Foo </span>&amp; <span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> Foo &amp;<span style="color: #000000;">f);
};</span></pre>
</div>
<p>示例中，返回值是左值的引用，如果设置返回值为void，那么就会阻止串联赋值（a=b=c）。一般应该返回左值的引用。</p>
<h1>小结</h1>
<p>不得不说，C++的语法细节太多，编译器常常在背后自动做了不少事情，很容易让程序员误入陷阱。相比之下，Java在语法这一块就简洁明晰很多了。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-19-2013-03-19-blog-25.html" data-id="ckdpm8hq5000mqpda88dw3j2e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-17-blog-26" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-17-2013-03-17-blog-26.html" class="article-date">
  <time datetime="2013-03-17T02:03:00.000Z" itemprop="datePublished">2013-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-17-2013-03-17-blog-26.html">C++中lambda的实现(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在看C++ Primer的过程中，发现C++11标准中添加了lambda和类型推断系统。这篇文章介绍了很多<a title="初探C++11之lambda表达式" href="http://www.cnblogs.com/l00l/archive/2012/02/04/2338038.html" target="_blank">lambda的实例</a>。</p>
<p>为了弄清楚lambda的实现，特地做了一个小实验。这一次只看non-mutable lambda。测试的gcc版本为4.6.3（貌似4.5以前的gcc不支持lambda表达式）。</p>
<p>代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">test.cpp</span>
<span style="color: #008080;"> 2</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 3</span> template&lt;typename Func&gt;
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test(Func f){
</span><span style="color: #008080;"> 5</span>     std::cout&lt;&lt;f(<span style="color: #800080;">3</span>)&lt;&lt;<span style="color: #000000;">std::endl;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 7</span> template&lt;typename Func&gt;
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2(Func f){
</span><span style="color: #008080;"> 9</span>     std::cout&lt;&lt;f(<span style="color: #800080;">13</span>)&lt;&lt;<span style="color: #000000;">std::endl;
</span><span style="color: #008080;">10</span> <span style="color: #000000;">}
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">12</span>     <span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">int</span> b = <span style="color: #800080;">2</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span>     auto f = [a,b](<span style="color: #0000ff;">int</span> c){<span style="color: #0000ff;">return</span> a+b+<span style="color: #000000;">c;};
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    test(f);
</span><span style="color: #008080;">16</span>     a=<span style="color: #800080;">2</span>;b=<span style="color: #800080;">3</span><span style="color: #000000;">;
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    test2(f);
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">19</span> }</pre>
</div>
<p>编译方法</p>
<div class="cnblogs_code">
<pre>g++ -std=c++0x test.<span style="color: #0000ff;">cpp</span> -o test</pre>
</div>
<p>运行结果</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">./test
</span>6
16</pre>
</div>
<p>在这个例子中，代码第14行创建了一个non-mutable lambda。这里使用了类型自动推断，f的类型编译器会自动计算出来。[]称为capture list，里面的a和b的值同main里面的a和b的值是一样的，而且可以发现non-mutable lambda创建之后再对main中的a、b赋值，不会影响到capture list中的a和b的值。此外capture list中a和b是只读的，试图写这两个值时，编译器会报错。这个lamda函数的返回值类型是int，这也可以由编译器自动推断出来。</p>
<p>现在来看看生成的汇编代码，来看看C++是如何实现non-mutable lambda的。</p>
<p>下面这一段是从main函数的汇编代码中截取出来的，对应了C++代码第12行到15行。各行的意义参见注释。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #800080;">8048612</span>:       c7 <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">18</span> <span style="color: #800080;">01</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movl   $0x1,0x18(%esp)  #给main中的a赋值
</span><span style="color: #008080;"> 2</span>  <span style="color: #800080;">8048619</span>:       <span style="color: #800080;">00</span> 
<span style="color: #008080;"> 3</span>  8<span style="color: #800080;">04861a</span>:       c7 <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> 1c <span style="color: #800080;">02</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movl   $0x2,0x1c(%esp) #给main中的b赋值
</span><span style="color: #008080;"> 4</span>  <span style="color: #800080;">8048621</span>:       <span style="color: #800080;">00</span> 
<span style="color: #008080;"> 5</span>  <span style="color: #800080;">8048622</span>:       8b <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">18</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x18(%esp),%eax 
</span><span style="color: #008080;"> 6</span>  <span style="color: #800080;">8048626</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">10</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %eax,0x10(%esp) #将main中的a值copy到capture list中的a（记为c_a)
</span><span style="color: #008080;"> 7</span>  8<span style="color: #800080;">04862a</span>:       8b <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> 1c             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x1c(%esp),%eax
</span><span style="color: #008080;"> 8</span>  8<span style="color: #800080;">04862e</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">14</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %eax,0x14(%esp) #将main中的b值copy到capture list中的b (记为c_b)
</span><span style="color: #008080;"> 9</span>  <span style="color: #800080;">8048632</span>:       8b <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">10</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x10(%esp),%eax 
</span><span style="color: #008080;">10</span>  <span style="color: #800080;">8048636</span>:       8b <span style="color: #800080;">54</span> <span style="color: #800080;">24</span> <span style="color: #800080;">14</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x14(%esp),%edx
</span><span style="color: #008080;">11</span>  8<span style="color: #800080;">04863a</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">04</span> <span style="color: #800080;">24</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %eax,(%esp)     #%eax中放着c_a的值
</span><span style="color: #008080;">12</span>  8<span style="color: #800080;">04863d</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">54</span> <span style="color: #800080;">24</span> <span style="color: #800080;">04</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %edx,0x4(%esp)  #将capture list中a、b的值分别取出，放在栈上作为函数调用的参数<br />　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 #(分别记为c_a_copy1, c_b_copy1)
</span><span style="color: #008080;">13</span>  <span style="color: #800080;">8048641</span>:       e8 2b <span style="color: #800080;">00</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span>          <span style="color: #0000ff;">call</span>   <span style="color: #800080;">8048671</span> &lt;_Z4testIZ4mainEUliE_EvT_&gt; #调用test(f)</pre>
</div>
<p>下面这一段是从函数模版test的汇编代码中截取的一段，对应了test中的f(3)这个表达式。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>  <span style="color: #800080;">8048677</span>:       c7 <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">04</span> <span style="color: #800080;">03</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movl   $0x3,0x4(%esp)   #将3作为参数放在栈上
</span><span style="color: #008080;">2</span>  8<span style="color: #800080;">04867e</span>:       <span style="color: #800080;">00</span> 
<span style="color: #008080;">3</span>  8<span style="color: #800080;">04867f</span>:       8d <span style="color: #800080;">45</span> <span style="color: #800080;">08</span>                <span style="color: #0000ff;">lea</span><span style="color: #000000;">    0x8(%ebp),%eax   #0x8(%ebp)对应的地址就是c_a_copy1
</span><span style="color: #008080;">4</span>  <span style="color: #800080;">8048682</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">04</span> <span style="color: #800080;">24</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %eax,(%esp)      #将这个地址(c_a_copy1的地址）放在栈上
</span><span style="color: #008080;">5</span>  <span style="color: #800080;">8048685</span>:       e8 6a ff ff ff          <span style="color: #0000ff;">call</span>   8<span style="color: #800080;">0485f4</span> &lt;_ZZ4mainENKUliE_clEi&gt; #调用lambda的代码</pre>
</div>
<p>下面是lambda代码对应的汇编码</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> 8<span style="color: #800080;">0485f7</span>:       8b <span style="color: #800080;">45</span> <span style="color: #800080;">08</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x8(%ebp),%eax    #将c_a_copy1的地址取出
</span><span style="color: #008080;">2</span>  8<span style="color: #800080;">0485fa</span>:       8b <span style="color: #800080;">10</span>                   <span style="color: #0000ff;">mov</span><span style="color: #000000;">    (%eax),%edx　　　 #%edx中存放c_a_copy1的值
</span><span style="color: #008080;">3</span>  8<span style="color: #800080;">0485fc</span>:       8b <span style="color: #800080;">45</span> <span style="color: #800080;">08</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x8(%ebp),%eax
</span><span style="color: #008080;">4</span>  8<span style="color: #800080;">0485ff</span>:       8b <span style="color: #800080;">40</span> <span style="color: #800080;">04</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x4(%eax),%eax   #%eax中存放着c_b_copy1的值
</span><span style="color: #008080;">5</span>  <span style="color: #800080;">8048602</span>:       <span style="color: #800080;">01</span> d0                   <span style="color: #0000ff;">add</span><span style="color: #000000;">    %edx,%eax
</span><span style="color: #008080;">6</span>  <span style="color: #800080;">8048604</span>:       <span style="color: #800080;">03</span> <span style="color: #800080;">45</span> <span style="color: #800080;">0c</span>                <span style="color: #0000ff;">add</span>    0xc(%ebp),%eax　　#0xc(%ebp)中放着参数c的值，着两行对应a+b+c</pre>
</div>
<p>从上面的代码来看，C++在编译lambda的时将lambda作为一个特殊的函数来处理。non-mutable lambda编译出来的代码与函数的代码类似，capture list中的值是存放在创建者（本例中是main函数）的栈上的。使用non-mutable lambda的时候，capture list中的值被拷贝出来放在调用栈上，在lambda函数中取出来使用。</p>
<p>下面再来看一下main中的另一段汇编代码，这一段代码对应着C++中的16和17行。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>  <span style="color: #800080;">8048646</span>:       c7 <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">18</span> <span style="color: #800080;">02</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movl   $0x2,0x18(%esp)   #给a赋值为2，没有影响c_a的值
</span><span style="color: #008080;">2</span>  8<span style="color: #800080;">04864d</span>:       <span style="color: #800080;">00</span> 
<span style="color: #008080;">3</span>  8<span style="color: #800080;">04864e</span>:       c7 <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> 1c <span style="color: #800080;">03</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span><span style="color: #000000;">    movl   $0x3,0x1c(%esp)   #给b赋值为3，没有影响到c_b的值
</span><span style="color: #008080;">4</span>  <span style="color: #800080;">8048655</span>:       <span style="color: #800080;">00</span> 
<span style="color: #008080;">5</span>  <span style="color: #800080;">8048656</span>:       8b <span style="color: #800080;">44</span> <span style="color: #800080;">24</span> <span style="color: #800080;">10</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x10(%esp),%eax
</span><span style="color: #008080;">6</span>  8<span style="color: #800080;">04865a</span>:       8b <span style="color: #800080;">54</span> <span style="color: #800080;">24</span> <span style="color: #800080;">14</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    0x14(%esp),%edx
</span><span style="color: #008080;">7</span>  8<span style="color: #800080;">04865e</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">04</span> <span style="color: #800080;">24</span>                <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %eax,(%esp)
</span><span style="color: #008080;">8</span>  <span style="color: #800080;">8048661</span>:       <span style="color: #800080;">89</span> <span style="color: #800080;">54</span> <span style="color: #800080;">24</span> <span style="color: #800080;">04</span>             <span style="color: #0000ff;">mov</span><span style="color: #000000;">    %edx,0x4(%esp)    #仍然是从c_a和c_b中拷贝值放在栈上
</span><span style="color: #008080;">9</span>  <span style="color: #800080;">8048665</span>:       e8 <span style="color: #800080;">42</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span> <span style="color: #800080;">00</span>          <span style="color: #0000ff;">call</span>   8<span style="color: #800080;">0486ac</span> &lt;_Z5test2IZ4mainEUliE_EvT_&gt; #调用test2(f)，后面部分的原理与test(f)相似</pre>
</div>
<p>从这段代码我们可以看出，capture list中的变量的值使用的是non-mutable lambda创建的时刻的值，以后不随着capture list外的值的变化而变化。</p>
<p>这篇文章分析了一下<a title="C++ lambda实现" target="_blank" rel="noopener" href="http://www.cnblogs.com/richardustc/archive/2013/03/31/2991865.html">mutable lambda的实现</a>。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-17-2013-03-17-blog-26.html" data-id="ckdpm8hq1000dqpda15lnbaoz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-17-blog-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-17-2013-03-17-blog-27.html" class="article-date">
  <time datetime="2013-03-16T23:03:00.000Z" itemprop="datePublished">2013-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-17-2013-03-17-blog-27.html">C++中的算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++中将算法和容器进行了很好的分离。容器用来存储数据，仅仅提供一些基本的操作，而算法则做到跟底层的数据结构无关。联系容器和算法的关键是迭代器。</p>
<p>算法不会更改容器的大小，但是也有一些特殊情况，执行过算法之后容器的大小改变了。但是要注意的是，改变容器大小的不是算法，而是迭代器。比如，这里有一个<a title="back_inserter" href="http://www.cplusplus.com/reference/iterator/back_inserter/" target="_blank">back_inserter的例子</a>。unique算法是去掉容器中重复的元素，执行unique完算法之后，会返回一个新的指向容器末尾的迭代器，程序员需要自己手动删除新尾到原尾之间的元素。</p>
<p>使用算法的时候需要注意的是算法一般不会对容器的大小、迭代器是否有效进行检查，这些都需要程序员在调用算法之前自己检查。</p>
<p>C++标准库中的算法主要集中在&lt;algorithm&gt;和&lt;numeric&gt;中。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-17-2013-03-17-blog-27.html" data-id="ckdpm8hpv0003qpdahforadsc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-15-blog-28" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-15-2013-03-15-blog-28.html" class="article-date">
  <time datetime="2013-03-14T21:03:00.000Z" itemprop="datePublished">2013-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Other/">Other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-15-2013-03-15-blog-28.html">QEMU编译及使用方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>QEMU是一个支持跨平台虚拟化的虚拟机，有user mode和system mode两种配置方式。其中qemu在system mode配置下模拟出整个计算机，可以在qemu之上运行一个操作系统。QEMU的system mode与常见的VMware和Virtualbox等虚拟机比较相似，但是QEMU的优势是可以跨指令集。例如，VMware和Virtualbox之类的工具通常只能在x86计算机上虚拟出一个x86计算机，而QEMU支持在x86上虚拟出一个ARM计算机。qemu在user mode配置下，可以运行跟当前平台指令集不同的平台可执行程序。例如可以用qemu在x86上运行ARM的可执行程序，但是两个平台必须是同一种操作系统，比如Linux。</p>
<p>QEMU还支持很多其他的平台，<a title="QEMU支持列表" href="http://qemu.weilnetz.de/qemu-doc.html#intro_005ffeatures" target="_blank">详细列表参见这里</a>。</p>
<p>QEMU中有两个重要的名词host和target(guest)，其中host表示qemu程序本身运行的平台，target(guest)表示qemu虚拟出的计算机平台(system mode)或支持的可执行程序的运行平台(user mode)。</p>
<p>下面描述一下编译和使用host为x86，target(guest)为ARM的步骤</p>
<p>1. 下载QEMU源码</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">wget</span> http:<span style="color: #008000;">//</span><span style="color: #008000;">wiki.qemu-project.org/download/qemu-1.4.0.tar.bz2</span></pre>
</div>
<p>2. 解压、configure</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">tar</span> xvf qemu-<span style="color: #800080;">1.4</span>.<span style="color: #800080;">0</span>.<span style="color: #0000ff;">tar</span><span style="color: #000000;">.bz2
cd qemu</span>-<span style="color: #800080;">1.4</span>.<span style="color: #800080;">0</span><span style="color: #000000;">
.</span>/configure --target-list=arm-softmmu,arm-linux-user --prefix=&lt;prefix&gt;</pre>
</div>
<p>其中--target-list指定需要编译的target(guest)，arm-softmmu表示要编译system mode的QEMU，arm-linux-user表示要编译user mode的QEMU。</p>
<p>如果configure提示缺少某些库的话，按照提示安装即可。</p>
<p>3. make和安装</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">make</span> &amp;&amp; <span style="color: #0000ff;">make</span> <span style="color: #0000ff;">install</span></pre>
</div>
<p>编译完成之后，得到的qemu-system-arm对应的就是system mode的虚拟机，qemu-arm对应的就是user mode的模拟器。</p>
<p>4. 使用qemu-arm</p>
<p>使用qemu-arm的方法很简单，只需要在原来的程序执行命令之前添加qemu-arm即可。</p>
<p><span>例如： 原来运行命令</span></p>
<div class="cnblogs_code">
<pre>&lt;executable&gt; &lt;arg1&gt; &lt;arg2&gt;&nbsp;...</pre>
</div>
<p>&nbsp;&nbsp;使用qemu-arm运行</p>
<div class="cnblogs_code">
<pre>qemu-arm &lt;executable&gt; &lt;arg1&gt; &lt;arg2&gt; ...</pre>
</div>
<p>5. 使用qemu-system-arm</p>
<p>使用qemu-system-arm的方法相对稍微复杂。</p>
<p>这里有一个<a target="_blank" rel="noopener" href="http://www.aurel32.net/info/debian_arm_qemu.php">qemu-system-arm安装使用debian教程</a>，教程中用到的版本比较老，可以<a href="http://people.debian.org/~aurel32/qemu/armel/" target="_blank">在这里下载较新的版本</a>，安装原理是类似的。</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-15-2013-03-15-blog-28.html" data-id="ckdpm8hpz0008qpdahswn52h0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-14-blog-29" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-14-2013-03-14-blog-29.html" class="article-date">
  <time datetime="2013-03-14T05:03:00.000Z" itemprop="datePublished">2013-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-14-2013-03-14-blog-29.html">C++中的顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继续之前的C++复习笔记。</p>
<p>顺序容器中放置的元素不能是引用或者不可复制的对象（比如输入输出流对象）。</p>
<p>C++中的顺序容器有vector、deque、forward_list。</p>
<p>在复习这一部分的时候，遇到了C++中的adaptor的概念。adaptor在用已有的类（函数、迭代器）为基础，创造出另一种不同功能的类（函数、迭代器）。</p>
<p>例如</p>
<div class="cnblogs_code">
<pre>stack&lt;<span style="color: #0000ff;">int,</span> vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; s;</pre>
</div>
<p>里面的stack类使用vector作为基础数据结构，利用vector的成员函数包装出back(), push_back()和pop()，实现栈功能。</p>
<p>C++中的顺序容器：</p>
<p>1. vector</p>
<p>2. deque</p>
<p>3. forward_list</p>
<p>4. stack</p>
<p>5. queue</p>
<p>6. priority_queue</p>
<p>7. ...</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-14-2013-03-14-blog-29.html" data-id="ckdpm8hq0000bqpda44mwabl8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2013-03-13-blog-30" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013-03-13-2013-03-13-blog-30.html" class="article-date">
  <time datetime="2013-03-13T05:03:00.000Z" itemprop="datePublished">2013-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Toolchain/">Toolchain</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013-03-13-2013-03-13-blog-30.html">--build、--host和--target选项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在交叉编译configure时，通常会需要设置--build、--host和--target选项。各个选项的含义如下：</p>
<p>--build：编译所用的机器的平台。</p>
<p>--host：编译出的代码运行的平台。</p>
<p>--target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</p>
<p>在不涉及到交叉编译的时候，--build、--host、--target是一样的，不需要特别设置。交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置--build和--host选项。</p>
<p>通常，本机上的gcc、ld等工具是没有前缀的，这个时候--build可以设置为空。交叉编译工具链通常都有一个前缀，比如arm-unknown-linux-gnueabi-gcc，这个时候，--host就要设置为arm-unknown-linux-gnueabi。</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:false;">Example:
./configure --build='' --host=arm-unknown-gnueabi
</pre>
</div>
<p>这篇文章<a title="Configure with --host, --target and --build options" href="http://jingfenghanmax.blogspot.in/2010/09/configure-with-host-target-and-build.html" target="_blank">Configure with --host, --target and --build options</a>有更多的示例</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://richardustc.github.io/2013-03-13-2013-03-13-blog-30.html" data-id="ckdpm8hpy0007qpdack757rdu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">Next &amp;raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C#</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CPP/">CPP</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Command-Line/">Command-Line</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLVM/">LLVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PyQt/">PyQt</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Regex/">Regex</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Toolchain/">Toolchain</a><span class="category-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyQt/" rel="tag">PyQt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/PyQt/" style="font-size: 10px;">PyQt</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">四月 2013</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015-07-09-except-hook.html">python中的excepthook</a>
          </li>
        
          <li>
            <a href="/2015-07-06-create-PyQt-Program-with-Designer.html">使用Designer编写PyQt程序的简单流程</a>
          </li>
        
          <li>
            <a href="/2013-12-14-2013-12-14-c-sharp-basics.html">C# Type Basic</a>
          </li>
        
          <li>
            <a href="/2013-09-26-2013-09-26-generate-random-numbers.html">构造随机数生成器</a>
          </li>
        
          <li>
            <a href="/2013-09-16-2013-09-16-python-notes.html">Python笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Richard Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>